{"version":3,"sources":["Components/images/marsmap1k.jpg","Components/images/marsbump1k.jpg","Components/images/background.png","Components/endpage.jsx","Components/Controls.jsx","Components/Startpage.jsx","Components/Model.jsx","Components/algorithms/astar.js","Components/algorithms/Bestfs.js","Components/algorithms/bfs.js","Components/algorithms/bi-dijkstra.js","Components/algorithms/biastar.js","Components/algorithms/BiBestfs.js","Components/algorithms/bibfs.js","Components/algorithms/BiIastar.js","Components/algorithms/dijkstra.js","Components/algorithms/Iastar.js","Components/algorithms/IBestfs.js","Components/algorithms/IDAstar_new.js","Components/algorithms/jps.js","Components/algorithms/orthJPS.js","Components/PathfindingVisualizer/Node.jsx","Components/PathfindingVisualizer/PathfindingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","SpaceShip","useState","model","setModel","useEffect","GLTFLoader","load","object","scene","Loading","finished","set","width","setWidth","THREE","onLoad","onProgress","url","itemsLoaded","itemsTotal","useTransition","from","opacity","leave","update","map","item","key","props","div","className","style","endpage","state","height","shadowMap","camera","position","intensity","castShadow","angle","penumbra","shadow-mapSize-width","shadow-mapSize-height","shadow-bias","attach","args","fallback","autoRotate","enablePan","enableZoom","enableDamping","dampingFactor","rotateSpeed","maxPolarAngle","Math","PI","minPolarAngle","href","children","Component","extend","OrbitControls","Controls","controlsRef","useRef","useThree","gl","size","useFrame","current","ref","domElement","enableRotate","Startpage","color","sleep","ms","Promise","resolve","setTimeout","Mars","mesh","hovered","setHover","active","setActive","imgmars","useMemo","marsURL","bumpmap1","bumperURL","console","log","rotation","y","scale","onClick","e","onPointerOver","onPointerOut","bumpmap","bumpscale","Model","data","zoom","bind","enlarge","document","body","backgroundImage","img1","i","j","k","scaled","parseFloat","this","setState","a","window","location","isReachable","grid","r","c","length","wallweight","getneighbors","node","diagonalallowed","neighbors","temp","push","row","col","Heap","require","Astar","startNode","finishNode","h","openList","nodeA","nodeB","fscore","gscore","inopen","b","visitedNodesInOrder","empty","pop","isWall","inclosed","neighbor","ng","sqrt","hscore","previousNode","updateItem","Bestfs","heuristic","distance","unvisitedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","unvisitedNeighbors","filter","getUnvisitedNeighbors","value","localeCompare","abs","max","pow","x_dist","y_dist","min","bfs","queue","bidijkstra","TempEnd","TempStart","tempstart","_","cloneDeep","tempend","startvisited","temp1","unshift","endvisited","temp2","closestNodeEnd","unvisitedNeighbors2","next","bidfsans","ans","s","BiAstar","startopenList","endopenList","temp3","enode","temp4","eneighbors","eneighbor","temp5","nex","temp6","tempx","BiBestfs","updateUnvisitedNeighborsStart","closestNode2","updateUnvisitedNeighborsEnd","bbfs","startqueue","endqueue","ftNode","unvisitedNeighbor","neighbora","bibfsans","BiIastar","dijkstra","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","Iastar","IBestfs","IDAstar","depth","heurestics","dx","dy","dblock","cX","cY","dX","dY","blocked","direction","sign","identifySuccessors","successors","parent","x","nodeNeighbors","jumpPoint","jump","curr","nX","nY","oX","oY","Node","isFinish","isStart","isWallweight","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","PathfindingVisualizer","mouseIsPressed","fin","inf","pause","handleOptionChangefinite","handleOptionChangeinfinite","handleChange2","handleSubmit","event","parseInt","prompt","target","alert","preventDefault","getInitialGrid","newGrid","getNewGridWithWallToggled","animateShortestPath","getElementById","animate","n","successor","val","jps","direc","d","diff","l","jpsans","orthJPS","xcord","ycord","m","orthogonalans","grid1","node1","class","tabindex","visualizeDijkstra","visualizeBiDijkstra","visualizeDijkstraDiag","visualizeBiDijkstraDiag","visualizeBFS","visualizeBBFS","visualizeBFSwithdiagonals","visualizeBDBFS","visualizeIntelligentAstar","visualizeBiIntelligentAstar","visualizeIntelligentAstarDiag","visualizeBiIntelligentAstarDiag","visualizeAstar","visualizeBiAstarNodiagoanls","visualizeOrthAstar","visualizeBiAstarWithDiagonals","visualizeBestfs","visualizeBiBestfs","visualizeBestfsDiag","visualizeBiBestfsDiag","visualizeIBestfs","visualizeIBestfsDiag","visualizeIDAstar","visualizeIDAstarDiag","visualizeJPS","visualizeOrthJPS","type","name","checked","onChange","for","tabIndex","clearPath","clearwall","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","createNode","weight","slice","newNode","App","exact","path","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c4cac938.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/marsmap1k.56f226a5.jpg\";","module.exports = __webpack_public_path__ + \"static/media/marsbump1k.f68f2bda.jpg\";","module.exports = __webpack_public_path__ + \"static/media/background.ae5e05e2.png\";","import { OrbitControls } from \"drei\";\r\nimport React, { Component, Suspense, useEffect, useState } from \"react\";\r\nimport { a, useTransition } from \"react-spring\";\r\nimport { Canvas } from \"react-three-fiber\";\r\nimport * as THREE from \"three\";\r\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\r\nimport \"./endpage.css\";\r\n\r\nconst SpaceShip = () => {\r\n  const [model, setModel] = useState();\r\n\r\n  useEffect(() => {\r\n    new GLTFLoader().load(\"/scene-draco.gltf\", setModel);\r\n  });\r\n\r\n  return model ? <primitive object={model.scene} /> : null;\r\n};\r\n\r\nfunction Loading() {\r\n  const [finished, set] = useState(false);\r\n  const [width, setWidth] = useState(0);\r\n\r\n  useEffect(() => {\r\n    THREE.DefaultLoadingManager.onLoad = () => set(true);\r\n    THREE.DefaultLoadingManager.onProgress = (url, itemsLoaded, itemsTotal) =>\r\n      setWidth((itemsLoaded / itemsTotal) * 200);\r\n  }, []);\r\n\r\n  const props = useTransition(finished, null, {\r\n    from: { opacity: 1, width: 0 },\r\n    leave: { opacity: 0 },\r\n    update: { width },\r\n  });\r\n\r\n  return props.map(\r\n    ({ item: finished, key, props: { opacity, width } }) =>\r\n      !finished && (\r\n        <a.div className=\"loading\" key={key} style={{ opacity }}>\r\n          <div className=\"loading-bar-container\">\r\n            <a.div className=\"loading-bar\" style={{ width }} />\r\n          </div>\r\n        </a.div>\r\n      )\r\n  );\r\n}\r\n\r\nclass endpage extends Component {\r\n  state = {};\r\n  render() {\r\n    return (\r\n      <>\r\n        <div className=\"bg\" />\r\n        <h1>\r\n          TheEnd\r\n          <br />\r\n          <span></span>\r\n        </h1>\r\n        <Canvas\r\n          style={{ height: 950 }}\r\n          shadowMap\r\n          camera={{ position: [0, 0, 21] }}\r\n        >\r\n          <ambientLight intensity={0.75} />\r\n          <pointLight intensity={1} position={[-10, -30, -10]} />\r\n          <spotLight\r\n            castShadow\r\n            intensity={2.25}\r\n            angle={0.2}\r\n            penumbra={1}\r\n            position={[25, 25, 25]}\r\n            shadow-mapSize-width={1024}\r\n            shadow-mapSize-height={1024}\r\n            shadow-bias={-0.0001}\r\n          />\r\n          <fog attach=\"fog\" args={[\"#cc7b32\", 20, 25]} />\r\n          <Suspense fallback={null}>\r\n            <SpaceShip></SpaceShip>\r\n          </Suspense>\r\n          <OrbitControls\r\n            autoRotate\r\n            enablePan={false}\r\n            enableZoom={true}\r\n            enableDamping\r\n            dampingFactor={0.5}\r\n            rotateSpeed={1}\r\n            maxPolarAngle={Math.PI / 2}\r\n            minPolarAngle={Math.PI / 2}\r\n          />\r\n        </Canvas>\r\n        <div className=\"layer\" />\r\n        <Loading />\r\n        <a\r\n          href=\"https://github.com/HackGod2000/TouchDown.js\"\r\n          className=\"top-left\"\r\n          children=\"Github\"\r\n        />\r\n\r\n        <a\r\n          href=\"https://github.com/drcmda/react-three-fiber\"\r\n          className=\"top-right\"\r\n          children=\"+ react-three-fiber\"\r\n        />\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default endpage;\r\n","import React, { useRef } from \"react\";\r\nimport { extend, useFrame, useThree } from \"react-three-fiber\";\r\nimport OrbitControls from \"three-orbitcontrols\";\r\n\r\n//Controls teh camera view and orbitControls\r\n\r\nextend({ OrbitControls });\r\n\r\nfunction Controls() {\r\n  const controlsRef = useRef();\r\n  const { camera, gl, size } = useThree();\r\n\r\n  useFrame(() => controlsRef.current && controlsRef.current.update());\r\n\r\n  return (\r\n    <orbitControls\r\n      ref={controlsRef}\r\n      args={[camera, gl.domElement]}\r\n      enableRotate\r\n      enablePan={true}\r\n      //maxPolarAngle={Math.PI / 3}\r\n      //minPolarAngle={Math.PI}\r\n    />\r\n  );\r\n}\r\n\r\nexport default Controls;\r\n","import React from \"react\";\r\nimport \"./Model.css\";\r\n\r\nfunction Startpage() {\r\n  return (\r\n    <div className=\"text-box\">\r\n      <div className=\"heading\">INSTRUCTION</div>\r\n      <div className=\"text-box2\">\r\n        <p style={{ color: \"#fafafa\" }}>\r\n          Welcome to Mars! You will be taken to our land where you will have\r\n          some starting position and a destination; both can be altered by you\r\n          accordingly. Since you are all alone here, you have to reach your\r\n          destination as soon as possible. There will be many hurdles in your\r\n          way, which again can be decided by you. These hurdles will be in the\r\n          form of a weighted wall, and you have two kinds of walls: infinite\r\n          weighted and finite weighted walls. You cannot jump over the infinite\r\n          weighted wall at any cost whereas, in a finite weighted, you will\r\n          first choose a weight and then apply it your land and you can jump\r\n          over them, but this comes with some penalty. To help you find your\r\n          way, we have a bunch of algorithms which will help you to calculate\r\n          your <strong>shortest path</strong>. You can explore various options\r\n          under them.\r\n          <p style={{ color: \"#fafafa\" }}>\r\n            To land on Mars, click on <strong>START</strong>!\r\n          </p>\r\n          <p style={{ color: \"#fafafa\" }}>Enjoy your journey!</p>\r\n        </p>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Startpage;\r\n","import React, { Component, useMemo, useRef, useState } from \"react\";\r\nimport { Canvas, useFrame } from \"react-three-fiber\";\r\nimport * as THREE from \"three\";\r\nimport Controls from \"./Controls\";\r\nimport img1 from \"./images/background.png\";\r\nimport bumperURL from \"./images/marsbump1k.jpg\";\r\nimport marsURL from \"./images/marsmap1k.jpg\";\r\nimport \"./Model.css\";\r\nimport StartPage from \"./Startpage\";\r\n\r\nconsole.log(bumperURL);\r\n\r\nclass Model extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      data: [],\r\n      scale: [1, 1, 1],\r\n    };\r\n    this.zoom = this.zoom.bind(this);\r\n    this.enlarge = this.enlarge.bind(this);\r\n  }\r\n  componentDidMount() {\r\n    document.body.style.backgroundImage = `url(${img1})`;\r\n  }\r\n  enlarge(i, j, k) {\r\n    const scaled = parseFloat(`${i}.${j}${k}`, 10);\r\n    this.setState({ scale: [scaled, scaled, scaled] });\r\n  }\r\n  async zoom() {\r\n    for (let i = 1; i <= 2; i++) {\r\n      for (let j = 0; j <= 9; j++) {\r\n        for (let k = 0; k <= 9; k++) {\r\n          await this.enlarge(i, j, k);\r\n          await sleep(5);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  render() {\r\n    const { data } = this.state;\r\n    //<SpaceShip />\r\n    //\r\n    //console.log(data);\r\n    return (\r\n      //  Sonali startpage.jsx controls the design element of the page.\r\n\r\n      <>\r\n        <StartPage />\r\n        <div className=\"button-wrapper\">\r\n          <div\r\n            className=\"button\"\r\n            onClick={async () => {\r\n              await this.zoom();\r\n              window.location =\r\n                \"https://hackgod2000.github.io/TouchDown.js/#/algo\";\r\n            }}\r\n          >\r\n            START\r\n          </div>\r\n        </div>\r\n        <div className=\"canvas-div\">\r\n          <Canvas\r\n            //style={{ height: 950, width: 1650 }}\r\n            camera={{ position: [0, 0, 20] }}\r\n          >\r\n            <ambientLight intensity={1.0} />\r\n            <pointLight intensity={0.9} position={[-10, -25, -10]} />\r\n            <spotLight\r\n              castShadow\r\n              intensity={0.25}\r\n              angle={Math.PI / 8}\r\n              position={[25, 25, 15]}\r\n              shadow-mapSize-width={2048}\r\n              shadow-mapSize-height={2048}\r\n            />\r\n            <Controls />\r\n\r\n            <Mars position={[1.2, 0, 0]} scale={this.state.scale} />\r\n          </Canvas>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\nfunction sleep(ms) {\r\n  return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nfunction Mars(props) {\r\n  // This reference will give us direct access to the mesh\r\n  const mesh = useRef();\r\n\r\n  //const clothTexture = useLoader(TextureLoader(), marsURL);\r\n  //console.log(clothTexture);\r\n  // Set up state for the hovered and active state\r\n  const [hovered, setHover] = useState(false);\r\n  const [active, setActive] = useState(false);\r\n  const imgmars = useMemo(() => new THREE.TextureLoader().load(marsURL), [\r\n    marsURL,\r\n  ]);\r\n  const bumpmap1 = useMemo(() => new THREE.TextureLoader().load(bumperURL), [\r\n    bumperURL,\r\n  ]);\r\n  console.log(marsURL);\r\n  // Rotate mesh every frame, this is outside of React without overhead\r\n  useFrame(() => (mesh.current.rotation.y += 0.006));\r\n  return (\r\n    <mesh\r\n      {...props}\r\n      ref={mesh}\r\n      scale={props.scale}\r\n      onClick={(e) => {\r\n        setActive(!active);\r\n      }}\r\n      onPointerOver={(e) => setHover(true)}\r\n      onPointerOut={(e) => setHover(false)}\r\n    >\r\n      <sphereGeometry attach=\"geometry\" args={[6, 26, 26]} />\r\n      <meshStandardMaterial\r\n        attach=\"material\"\r\n        color={hovered ? \"hotpink\" : \"orange\"}\r\n        map={imgmars}\r\n        bumpmap={bumpmap1}\r\n        bumpscale={0.1}\r\n      />\r\n    </mesh>\r\n  );\r\n}\r\n\r\nexport default Model;\r\n","function isReachable(grid, r, c) {\r\n  if (-1 < r && -1 < c && r < grid.length && c < grid[0].length) {\r\n    if (!grid[r][c].wallweight < 99999999) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\nfunction getneighbors(grid, node, diagonalallowed) {\r\n  var neighbors = [];\r\n  // else{\r\n  var temp = [\r\n    [-1, 0],\r\n    [0, -1],\r\n    [0, 1],\r\n    [1, 0],\r\n  ];\r\n  // }\r\n  if (diagonalallowed) {\r\n    temp.push([-1, -1]);\r\n    temp.push([1, -1]);\r\n    temp.push([1, 1]);\r\n    temp.push([-1, 1]);\r\n  }\r\n  for (var i = 0; i < temp.length; i++) {\r\n    var r = node.row + temp[i][0];\r\n    var c = node.col + temp[i][1];\r\n    if (isReachable(grid, r, c)) {\r\n      neighbors.push(grid[r][c]);\r\n    }\r\n  }\r\n  return neighbors;\r\n}\r\nfunction heuristic(a, b) {\r\n  return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2);\r\n}\r\nvar Heap = require(\"heap\");\r\nexport function Astar(grid, startNode, finishNode, h, diagonalallowed) {\r\n  //console.log(diagonalallowed)\r\n  var openList = new Heap(function (nodeA, nodeB) {\r\n    return nodeA.fscore - nodeB.fscore;\r\n  });\r\n  startNode.gscore = 0;\r\n  startNode.fscore = 0;\r\n  openList.push(startNode);\r\n  startNode.inopen = true;\r\n  const visitedNodesInOrder = [];\r\n  while (!openList.empty()) {\r\n    var node = openList.pop();\r\n    if (node.isWall && node.wallweight === 99999999) {\r\n      continue;\r\n    }\r\n    node.inclosed = true;\r\n\r\n    visitedNodesInOrder.push(node);\r\n    if (node === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    var neighbors = getneighbors(grid, node, diagonalallowed);\r\n    for (var i = 0; i < neighbors.length; i++) {\r\n      var neighbor = neighbors[i];\r\n      if (!neighbor.inclosed) {\r\n        var r = neighbor.row;\r\n        var c = neighbor.col;\r\n        var ng =\r\n          node.gscore +\r\n          Math.sqrt(\r\n            (neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2\r\n          );\r\n        if (!neighbor.inopen || ng < neighbor.gscore) {\r\n          neighbor.gscore = ng;\r\n          neighbor.hscore = heuristic(neighbor, finishNode);\r\n          neighbor.fscore =\r\n            neighbor.gscore + neighbor.hscore * neighbor.wallweight;\r\n          neighbor.previousNode = node;\r\n\r\n          if (!neighbor.inopen) {\r\n            openList.push(neighbor);\r\n            neighbor.inopen = true;\r\n          } else {\r\n            openList.updateItem(neighbor);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n","//This is my variation of BEST FIRST SEARCH\r\nexport function Bestfs(grid, startNode, finishNode,heuristic,diagonalallowed) {\r\n    const visitedNodesInOrder = []; //closed list\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid); //open list\r\n    while (unvisitedNodes.length>0) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall && closestNode.wallweight==99999999) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid,finishNode,heuristic,diagonalallowed,closestNode.wallweight);\r\n    }\r\n  }\r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(node, grid,finishNode,heuristic,diagonalallowed,wallweight) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      console.log(finishNode.col);\r\n      console.log(neighbor.col);\r\n      var value;\r\n      var string=\"Manhattan\";\r\n      var string2=\"Diagonal\";\r\n      var string3=\"Euclidean\";\r\n      var string4=\"Octile\";\r\n      var string5=\"Chebyshev\";\r\n      if(heuristic.localeCompare(string)==0)\r\n      {\r\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string2)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string3)==0)\r\n      {\r\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string4)==0)\r\n      {\r\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\r\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\r\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string5)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      neighbor.distance=value*wallweight;\r\n      neighbor.previousNode = node;\r\n      neighbor.isVisited=true;\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (diagonalallowed){\r\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n      \r\n    }\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  function getNodesInShortestPathOrder(finishNode) \r\n  {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n  ","export function bfs(grid,startNode,finishNode,diagonalallowed){\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const queue = [startNode];\r\n  while (!!queue.length){\r\n    const closestNode = queue.shift();\r\n    if (closestNode.wallweight === 99999999) continue ;\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors){\r\n      neighbor.previousNode = closestNode;\r\n      neighbor.isVisited = true;\r\n      neighbor.distance = closestNode.distance + neighbor.wallweight;\r\n      queue.push(neighbor);\r\n    }\r\n\r\n  }\r\n  return visitedNodesInOrder\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (diagonalallowed){\r\n    if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n    if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n    if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n    if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n    \r\n  }\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nimport _ from \"lodash\" ;\r\nexport function bidijkstra(grid,startNode,finishNode,diagonalallowed){\r\n    const visitedNodesInOrder = [];\r\n    const TempEnd=[];\r\n    const TempStart=[];\r\n    const tempstart = _.cloneDeep(startNode);\r\n    tempstart.distance=0;\r\n    const tempend = _.cloneDeep(finishNode);\r\n    tempend.distance=0;\r\n    TempStart.push(tempstart);\r\n    TempEnd.push(tempend);\r\n    while (TempStart.length>0 && TempEnd.length>0){\r\n        sortNodesByDistance(TempStart);\r\n      const closestNode = TempStart.shift();\r\n      if (closestNode.isWall && closestNode.wallweight==999999) continue ;\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.startvisited = true;\r\n      const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\r\n      for (const neighbor of unvisitedNeighbors){\r\n        if (neighbor.startvisited) continue ;\r\n        // console.log(\"Neighbor updating\");  \r\n        // closestNode.next=neighbor;\r\n        neighbor.previousNode = closestNode;\r\n          neighbor.startvisited = true;\r\n          neighbor.distance = closestNode.distance + closestNode.wallweight;\r\n          TempStart.push(neighbor);\r\n      }\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) {\r\n          console.log(\"Hello\");\r\n        var temp1 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp1)\r\n        return visitedNodesInOrder;\r\n      }\r\n      if (closestNode.endvisited){\r\n          // console.log(\"Hi\");\r\n        var temp2 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp2)\r\n        return visitedNodesInOrder;\r\n      }\r\n      \r\n      // console.log(\"Entering another field\");\r\n      sortNodesByDistance(TempEnd);\r\n      const closestNodeEnd = TempEnd.shift();\r\n      if (closestNodeEnd.isWall && closestNodeEnd.wallweight==999999) continue ;\r\n      if (closestNodeEnd.distance === Infinity) return visitedNodesInOrder;\r\n      closestNodeEnd.endvisited = true;\r\n      const unvisitedNeighbors2 = getUnvisitedNeighbors(closestNodeEnd, grid,diagonalallowed);\r\n      for (const neighbor of unvisitedNeighbors2){\r\n        if (neighbor.endvisited) continue ;\r\n         neighbor.next=closestNodeEnd; \r\n         // neighbor.previousNode = closestNodeEnd;\r\n          neighbor.endvisited = true;\r\n          neighbor.distance = closestNodeEnd.distance + closestNodeEnd.wallweight;\r\n          TempEnd.push(neighbor);\r\n          // console.log(\"Neighbor updation\");\r\n      }\r\n      visitedNodesInOrder.push(closestNodeEnd);\r\n      if (closestNodeEnd === startNode) {\r\n          console.log(\"Reached End\");\r\n        var temp1 = [closestNodeEnd];\r\n        visitedNodesInOrder.unshift(temp1)\r\n        return visitedNodesInOrder;\r\n      }\r\n      if (closestNodeEnd.startvisited){\r\n          console.log(\"Hurrayyyy!!!\");\r\n        var temp2 = [closestNodeEnd];\r\n        visitedNodesInOrder.unshift(temp2)\r\n        return visitedNodesInOrder;\r\n      }\r\n      \r\n      \r\n    }\r\n    while ( TempStart.length>0){\r\n        // console.log(\"Start side left\");\r\n        sortNodesByDistance(TempStart);\r\n      const closestNode = TempStart.shift();\r\n      if (closestNode.isWall && closestNode.wallweight==999999) continue ;\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.startvisited = true;\r\n      const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\r\n      for (const neighbor of unvisitedNeighbors){\r\n        if (neighbor.startvisited) continue ;\r\n         neighbor.previousNode = closestNode;\r\n          neighbor.startvisited = true;\r\n          neighbor.distance = closestNode.distance + closestNode.wallweight;\r\n          TempStart.push(neighbor);\r\n      }\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) {\r\n        var temp1 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp1)\r\n        return visitedNodesInOrder;\r\n      }\r\n      if (closestNode.endvisited){\r\n        var temp2 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp2)\r\n        return visitedNodesInOrder;\r\n      }\r\n\r\n      \r\n    }\r\n    while (TempEnd.length>0){\r\n        // console.log(\"End side left\");\r\n      sortNodesByDistance(TempEnd);\r\n      const closestNodeEnd = TempEnd.shift();\r\n      if (closestNodeEnd.isWall && closestNodeEnd.wallweight==999999) continue ;\r\n      if (closestNodeEnd.distance === Infinity) return visitedNodesInOrder;\r\n      closestNodeEnd.endvisited = true;\r\n      const unvisitedNeighbors2 = getUnvisitedNeighbors(closestNodeEnd, grid,diagonalallowed);\r\n      for (const neighbor of unvisitedNeighbors2){\r\n        if (neighbor.endvisited) continue ;\r\n        neighbor.next=closestNodeEnd;\r\n          neighbor.endvisited = true;\r\n          neighbor.distance = closestNodeEnd.distance + closestNodeEnd.wallweight;\r\n          TempEnd.push(neighbor);\r\n      }\r\n      visitedNodesInOrder.push(closestNodeEnd);\r\n      if (closestNodeEnd === startNode) {\r\n        var temp1 = [closestNodeEnd];\r\n        visitedNodesInOrder.unshift(temp1)\r\n        return visitedNodesInOrder;\r\n      }\r\n      if (closestNodeEnd.startvisited){\r\n        var temp2 = [closestNodeEnd];\r\n        visitedNodesInOrder.unshift(temp2)\r\n        return visitedNodesInOrder;\r\n      }\r\n      \r\n    }\r\n  }\r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  \r\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (diagonalallowed){\r\n        if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n        if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n        if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n        if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n    }\r\n    return neighbors\r\n  }\r\n  \r\n  \r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called after the dijkstra method above.\r\n  export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n  export function bidfsans(node) {\r\n\r\n    // return [node];\r\n    console.log(node);\r\n    var ans = [];\r\n    let s = node;  \r\n    let e = node;\r\n    // console.log(s);\r\n    // console.log(e);\r\n    while (s.previousNode !== null && e.next!== null){\r\n      ans.unshift(s.previousNode);\r\n      ans.unshift(e.next);\r\n      s = s.previousNode;\r\n      e = e.next ;\r\n    }\r\n    while (s.previousNode !== null){\r\n        // console.log(\"Wohooo\");\r\n      ans.unshift(s.previousNode);\r\n      s = s.previousNode;\r\n    }\r\n    while (e.next !== null){\r\n      ans.unshift(e.next);\r\n      e = e.next ;\r\n    }\r\n    ans.push(node)\r\n    return ans\r\n  }\r\n  ","// function isReachable(grid,r,c){\r\n//     if (-1 < r && -1 < c && r < grid.length && c <grid[0].length){\r\n//         if (!grid[r][c].isWall){\r\n//             return true\r\n//         }\r\n//     }\r\n//     return false\r\n// }\r\n// function heuristic(a,b,h){\r\n//     if (h === 1){\r\n//         // Euclidean\r\n//        return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\r\n//     }\r\n//     if (h === 2){\r\n//         // Manhattan\r\n//         return b.row - a.row + b.col - a.col\r\n//     }\r\n//     if (h === 3){\r\n//         // octile\r\n//         var a = Math.sqrt(2) - 1\r\n//         var dx = b.row - a.row \r\n//         var dy = b.col - a.col\r\n//         return dx + dy + (a- 2)*Math.min(dx,dy)\r\n\r\n//     }\r\n//     if (h === 4){\r\n//         // chebyshev\r\n//         var dx = b.row - a.row \r\n//         var dy = b.col - a.col\r\n//         return Math.max(dx,dy)\r\n//     }\r\n// }\r\n// var Heap = require('heap');\r\n// export function BiAstar(grid,startNode,finishNode,h){\r\n//     // console.log(startNode)\r\n//     var startopenList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\r\n    \r\n//     var endopenList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\r\n//     startNode.gscore = 0 ; finishNode.gscore = 0\r\n//     startNode.fscore = 0 ; finishNode.fscore = 0\r\n//     startopenList.push(startNode); endopenList.push(finishNode)\r\n//     startNode.inopen = true; finishNode.inopen = true\r\n//     const visitedNodesInOrder = [];\r\n//     while (!startopenList.empty() && !endopenList.empty()) {\r\n//         var node = startopenList.pop();\r\n//         node.inclosed = true;\r\n//         node.startvisited = true\r\n//         visitedNodesInOrder.push(node)\r\n//         if (node === finishNode){\r\n//             var temp1 = [node];\r\n//             console.log(1)\r\n//             visitedNodesInOrder.unshift(temp1)\r\n//             return visitedNodesInOrder;\r\n//         }\r\n//         var neighbors = getneighbors(grid,node)\r\n//         for (var i = 0; i<neighbors.length;i++){\r\n//             var neighbor = neighbors[i];\r\n//             if (neighbor.endvisited){\r\n//                 neighbor.previousNode = node\r\n//                 var temp2 = [neighbor];\r\n//                 console.log(2)\r\n//                 visitedNodesInOrder.unshift(temp2)\r\n//                 return visitedNodesInOrder;\r\n//             }\r\n//             if (!neighbor.inclosed) {\r\n//                 var r = neighbor.row; var c = neighbor.col ;\r\n//                 var ng = node.gscore + Math.sqrt((neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2)\r\n//                 if (!neighbor.inopen || ng < neighbor.gscore) {\r\n//                     neighbor.gscore = ng;\r\n//                     neighbor.hscore = heuristic(neighbor,finishNode,h);\r\n//                     neighbor.fscore = neighbor.gscore + neighbor.hscore;\r\n//                     neighbor.previousNode = node;\r\n\r\n//                     if (neighbor.endvisited){\r\n//                         var temp3 = [neighbor];\r\n//                         console.log(3)\r\n//                         visitedNodesInOrder.unshift(temp3)\r\n\r\n//                         return visitedNodesInOrder;\r\n//                     }\r\n//                     if (!neighbor.inopen) {\r\n//                         startopenList.push(neighbor);\r\n//                         neighbor.startvisited = true\r\n//                         neighbor.inopen = true;\r\n//                     } else {\r\n//                         startopenList.updateItem(neighbor);\r\n//                         neighbor.startvisited = true\r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         var enode = endopenList.pop();\r\n//         enode.inclosed = true;\r\n//         enode.endvisited = true\r\n//         visitedNodesInOrder.push(enode)\r\n//         if (enode === startNode){\r\n//             var temp4 = [enode];\r\n\r\n//             console.log(4)\r\n//             visitedNodesInOrder.unshift(temp4)\r\n//             return visitedNodesInOrder;\r\n//         }\r\n//         var eneighbors = getneighbors(grid,enode)\r\n//         for (var i = 0; i<eneighbors.length;i++){\r\n//             var eneighbor = eneighbors[i];\r\n//             if (eneighbor.startvisited){\r\n//                 var temp5 = [eneighbor];\r\n//                 eneighbor.nex = enode\r\n//                 console.log(5)\r\n//                 visitedNodesInOrder.unshift(temp5)\r\n//                 return visitedNodesInOrder;\r\n//             }\r\n//             if (!eneighbor.inclosed) {\r\n//                 var r = eneighbor.row; var c = eneighbor.col ;\r\n//                 var ng = enode.gscore + Math.sqrt((eneighbor.row - enode.row) ** 2 + (eneighbor.col - enode.col) ** 2)\r\n//                 if (!eneighbor.inopen || ng < eneighbor.gscore) {\r\n//                     eneighbor.gscore = ng;\r\n//                     eneighbor.hscore = heuristic(eneighbor,startNode,h);\r\n//                     eneighbor.fscore = eneighbor.gscore + eneighbor.hscore;\r\n//                     eneighbor.nex = enode;\r\n\r\n//                     if (eneighbor.startvisited){\r\n//                         var temp6 = [eneighbor];\r\n//                         console.log(6)\r\n//                         visitedNodesInOrder.unshift(temp6)\r\n\r\n//                         return visitedNodesInOrder;\r\n//                     }\r\n//                     if (!eneighbor.inopen) {\r\n//                         endopenList.push(eneighbor);\r\n//                         eneighbor.endvisited = true\r\n//                         eneighbor.inopen = true;\r\n//                     } else {\r\n//                         startopenList.updateItem(neighbor);\r\n//                         eneighbor.endvisited = true\r\n                        \r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//     }\r\n//     return visitedNodesInOrder\r\n// }\r\n\r\n\r\n\r\n\r\nfunction isReachable(grid,r,c){\r\n    if (-1 < r && -1 < c && r < grid.length && c <grid[0].length){\r\n        if (!grid[r][c].isWall){\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\nfunction getneighbors(grid,node,diagonalallowed){\r\n    var neighbors = []; \r\n    // console.log(diagonalallowed)\r\n    // else{\r\n    var temp = [[-1,0],[0,-1],[0,1],[1,0]]\r\n    // }\r\n    if (diagonalallowed){\r\n        temp.push([-1,-1])\r\n        temp.push([1,-1])\r\n        temp.push([1,1])\r\n        temp.push([-1,1])\r\n    }\r\n    for (var i = 0 ; i< temp.length ; i++){\r\n        var r = node.row+temp[i][0]\r\n        var c = node.col+temp[i][1]\r\n        if (isReachable(grid,r,c)){\r\n            neighbors.push(grid[r][c])\r\n        }\r\n    }\r\n    return neighbors\r\n}\r\nfunction heuristic(a,b){\r\n    return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\r\n}\r\nvar Heap = require('heap');\r\n// export function Astar(grid,startNode,finishNode,diagonalallowed){\r\n//     console.log(startNode)\r\n//     var openList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\r\n//     startNode.gscore = 0 ;\r\n//     startNode.fscore = 0 ; \r\n//     openList.push(startNode);\r\n//     startNode.inopen = true;\r\n//     const visitedNodesInOrder = [];\r\n//     while (!openList.empty()) {\r\n//         var node = openList.pop();\r\n//         node.inclosed = true;\r\n//         visitedNodesInOrder.push(node)\r\n//         if (node === finishNode){\r\n//             return visitedNodesInOrder;\r\n//         }\r\n//         var neighbors = getneighbors(grid,node,diagonalallowed)\r\n//         for (var i = 0; i<neighbors.length;i++){\r\n//             var neighbor = neighbors[i];\r\n//             if (!neighbor.inclosed) {\r\n//                 var r = neighbor.row; var c = neighbor.col ;\r\n//                 var ng = node.gscore + Math.sqrt((neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2)\r\n//                 if (!neighbor.inopen || ng < neighbor.gscore) {\r\n//                     neighbor.gscore = ng;\r\n//                     neighbor.hscore = heuristic(neighbor,finishNode);\r\n//                     neighbor.fscore = neighbor.gscore + neighbor.hscore;\r\n//                     neighbor.previousNode = node;\r\n\r\n//                     if (!neighbor.inopen) {\r\n//                         openList.push(neighbor);\r\n//                         neighbor.inopen = true;\r\n//                     } else {\r\n//                         openList.updateItem(neighbor);\r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n//     return visitedNodesInOrder\r\n// }\r\n\r\n\r\nexport function BiAstar(grid,startNode,finishNode,h,diagonalallowed){\r\n    // console.log(startNode)\r\n    var startopenList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\r\n    \r\n    var endopenList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\r\n    startNode.gscore = 0 ; finishNode.gscore = 0\r\n    startNode.fscore = 0 ; finishNode.fscore = 0\r\n    startopenList.push(startNode); endopenList.push(finishNode)\r\n    startNode.inopen = true; finishNode.inopen = true\r\n    const visitedNodesInOrder = [];\r\n    while (!startopenList.empty() && !endopenList.empty()) {\r\n        var node = startopenList.pop();\r\n        node.inclosed = true;\r\n        node.startvisited = true\r\n        visitedNodesInOrder.push(node)\r\n        if (node === finishNode){\r\n            var temp1 = [node];\r\n            console.log(1)\r\n            visitedNodesInOrder.unshift(temp1)\r\n            return visitedNodesInOrder;\r\n        }\r\n        var neighbors = getneighbors(grid,node,diagonalallowed)\r\n        for (var i = 0; i<neighbors.length;i++){\r\n            var neighbor = neighbors[i];\r\n            if (neighbor.endvisited){\r\n                neighbor.previousNode = node\r\n                var temp2 = [neighbor];\r\n                console.log(2)\r\n                visitedNodesInOrder.unshift(temp2)\r\n                return visitedNodesInOrder;\r\n            }\r\n            if (!neighbor.inclosed) {\r\n                var r = neighbor.row; var c = neighbor.col ;\r\n                var ng = node.gscore + Math.sqrt((neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2)\r\n                if (!neighbor.inopen || ng < neighbor.gscore) {\r\n                    neighbor.gscore = ng;\r\n                    neighbor.hscore = heuristic(neighbor,finishNode,h);\r\n                    neighbor.fscore = neighbor.gscore + neighbor.hscore;\r\n                    neighbor.previousNode = node;\r\n\r\n                    if (neighbor.endvisited){\r\n                        var temp3 = [neighbor];\r\n                        console.log(3)\r\n                        visitedNodesInOrder.unshift(temp3)\r\n\r\n                        return visitedNodesInOrder;\r\n                    }\r\n                    if (!neighbor.inopen) {\r\n                        startopenList.push(neighbor);\r\n                        neighbor.startvisited = true\r\n                        neighbor.inopen = true;\r\n                    } else {\r\n                        startopenList.updateItem(neighbor);\r\n                        neighbor.startvisited = true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var enode = endopenList.pop();\r\n        enode.inclosed = true;\r\n        enode.endvisited = true\r\n        visitedNodesInOrder.push(enode)\r\n        if (enode === startNode){\r\n            var temp4 = [enode];\r\n\r\n            visitedNodesInOrder.unshift(temp4)\r\n            return visitedNodesInOrder;\r\n        }\r\n        var eneighbors = getneighbors(grid,enode,diagonalallowed)\r\n        for (var i = 0; i<eneighbors.length;i++){\r\n            var eneighbor = eneighbors[i];\r\n            if (eneighbor.startvisited){\r\n                var temp5 = [eneighbor];\r\n                eneighbor.nex = enode\r\n                visitedNodesInOrder.unshift(temp5)\r\n                return visitedNodesInOrder;\r\n            }\r\n            if (!eneighbor.inclosed) {\r\n                var r = eneighbor.row; var c = eneighbor.col ;\r\n                var ng = enode.gscore + Math.sqrt((eneighbor.row - enode.row) ** 2 + (eneighbor.col - enode.col) ** 2)\r\n                if (!eneighbor.inopen || ng < eneighbor.gscore) {\r\n                    eneighbor.gscore = ng;\r\n                    eneighbor.hscore = heuristic(eneighbor,startNode,h);\r\n                    eneighbor.fscore = eneighbor.gscore + eneighbor.hscore;\r\n                    eneighbor.nex = enode;\r\n\r\n                    if (eneighbor.startvisited){\r\n                        var temp6 = [eneighbor];\r\n                        console.log(6)\r\n                        visitedNodesInOrder.unshift(temp6)\r\n\r\n                        return visitedNodesInOrder;\r\n                    }\r\n                    if (!eneighbor.inopen) {\r\n                        endopenList.push(eneighbor);\r\n                        eneighbor.endvisited = true\r\n                        eneighbor.inopen = true;\r\n                    } else {\r\n                        startopenList.updateItem(neighbor);\r\n                        eneighbor.endvisited = true\r\n                        \r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n    while (!startopenList.empty()){\r\n        var node = startopenList.pop();\r\n        // console.log(node)\r\n        // if (!node) continue;\r\n        node.inclosed = true;\r\n        node.startvisited = true\r\n        visitedNodesInOrder.push(node)\r\n        if (node === finishNode){\r\n            var temp1 = [node];\r\n            console.log(1)\r\n            visitedNodesInOrder.unshift(temp1)\r\n            return visitedNodesInOrder;\r\n        }\r\n        var neighbors = getneighbors(grid,node,diagonalallowed)\r\n        for (var i = 0; i<neighbors.length;i++){\r\n            var neighbor = neighbors[i];\r\n            // if (neighbor.endvisited){\r\n            //     neighbor.previousNode = node\r\n            //     var temp2 = [neighbor];\r\n            //     console.log(2)\r\n            //     visitedNodesInOrder.unshift(temp2)\r\n            //     return visitedNodesInOrder;\r\n            // }\r\n            if (!neighbor.inclosed) {\r\n                var r = neighbor.row; var c = neighbor.col ;\r\n                var ng = node.gscore + Math.sqrt((neighbor.row - node.row) ** 2 + (neighbor.col - node.col) ** 2)\r\n                if (!neighbor.inopen || ng < neighbor.gscore) {\r\n                    neighbor.gscore = ng;\r\n                    neighbor.hscore = heuristic(neighbor,finishNode,h);\r\n                    neighbor.fscore = neighbor.gscore + neighbor.hscore;\r\n                    neighbor.previousNode = node;\r\n\r\n                    if (neighbor.endvisited){\r\n                        var temp3 = [neighbor];\r\n                        console.log(3)\r\n                        visitedNodesInOrder.unshift(temp3)\r\n\r\n                        return visitedNodesInOrder;\r\n                    }\r\n                    if (!neighbor.inopen) {\r\n                        startopenList.push(neighbor);\r\n                        neighbor.startvisited = true\r\n                        neighbor.inopen = true;\r\n                    } else {\r\n                        startopenList.updateItem(neighbor);\r\n                        neighbor.startvisited = true\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    while (!endopenList.empty()){\r\n        var enode = endopenList.pop();\r\n        // console.log(enode)\r\n        // if (!enode) continue;\r\n        enode.inclosed = true;\r\n        enode.endvisited = true\r\n        visitedNodesInOrder.push(enode)\r\n        if (enode === startNode){\r\n            var temp4 = [enode];\r\n\r\n            visitedNodesInOrder.unshift(temp4)\r\n            return visitedNodesInOrder;\r\n        }\r\n        var eneighbors = getneighbors(grid,enode,diagonalallowed)\r\n        for (var i = 0; i<eneighbors.length;i++){\r\n            var eneighbor = eneighbors[i];\r\n            // if (eneighbor.startvisited){\r\n            //     var temp5 = [eneighbor];\r\n            //     eneighbor.nex = enode\r\n            //     visitedNodesInOrder.unshift(temp5)\r\n            //     return visitedNodesInOrder;\r\n            // }\r\n            if (!eneighbor.inclosed) {\r\n                var r = eneighbor.row; var c = eneighbor.col ;\r\n                var ng = enode.gscore + Math.sqrt((eneighbor.row - enode.row) ** 2 + (eneighbor.col - enode.col) ** 2)\r\n                if (!eneighbor.inopen || ng < eneighbor.gscore) {\r\n                    eneighbor.gscore = ng;\r\n                    eneighbor.hscore = heuristic(eneighbor,startNode,h);\r\n                    eneighbor.fscore = eneighbor.gscore + eneighbor.hscore;\r\n                    eneighbor.nex = enode;\r\n\r\n                    if (eneighbor.startvisited){\r\n                        var temp6 = [eneighbor];\r\n                        console.log(6)\r\n                        visitedNodesInOrder.unshift(temp6)\r\n\r\n                        return visitedNodesInOrder;\r\n                    }\r\n                    if (!eneighbor.inopen) {\r\n                        endopenList.push(eneighbor);\r\n                        eneighbor.endvisited = true\r\n                        eneighbor.inopen = true;\r\n                    } else {\r\n                        startopenList.updateItem(neighbor);\r\n                        eneighbor.endvisited = true\r\n                        \r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    var tempx = [finishNode]\r\n    visitedNodesInOrder.unshift(tempx)\r\n    return visitedNodesInOrder\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n","import _ from \"lodash\";\r\nexport function BiBestfs(\r\n  grid,\r\n  startNode,\r\n  finishNode,\r\n  heuristic,\r\n  diagonalallowed\r\n) {\r\n  const visitedNodesInOrder = []; //closed list\r\n  const TempEnd = [];\r\n  const TempStart = [];\r\n  const tempstart = _.cloneDeep(startNode);\r\n  tempstart.distance = 0;\r\n  const tempend = _.cloneDeep(finishNode);\r\n  tempend.distance = 0;\r\n  TempStart.push(tempstart);\r\n  TempEnd.push(tempend);\r\n  while (TempStart.length > 0 && TempEnd.length > 0) {\r\n    sortNodesByDistance(TempStart);\r\n    const closestNode = TempStart.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall && closestNode.wallweight == 99999999) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.startvisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    updateUnvisitedNeighborsStart(\r\n      closestNode,\r\n      grid,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed,\r\n      TempStart,\r\n      closestNode.wallweight\r\n    );\r\n    if (closestNode === finishNode) {\r\n      //console.log(\"Hello\");\r\n      var temp1 = [closestNode];\r\n      visitedNodesInOrder.unshift(temp1);\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (closestNode.endvisited) {\r\n      // //console.log(\"Hi\");\r\n      var temp2 = [closestNode];\r\n      visitedNodesInOrder.unshift(temp2);\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    sortNodesByDistance(TempEnd);\r\n    const closestNode2 = TempEnd.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode2.isWall && closestNode2.wallweight == 99999999) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode2.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode2.endvisited = true;\r\n    updateUnvisitedNeighborsEnd(\r\n      closestNode2,\r\n      grid,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed,\r\n      TempEnd,\r\n      closestNode2.wallweight\r\n    );\r\n    visitedNodesInOrder.push(closestNode2);\r\n    if (closestNode2 === startNode) {\r\n      //console.log(\"Hello\");\r\n      var temp1 = [closestNode2];\r\n      visitedNodesInOrder.unshift(temp1);\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (closestNode2.startvisited) {\r\n      //console.log(\"Hurrayyyy!!!\");\r\n      var temp2 = [closestNode2];\r\n      visitedNodesInOrder.unshift(temp2);\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n\r\n  while (TempStart.length > 0) {\r\n    // //console.log(\"Start side left\");\r\n    sortNodesByDistance(TempStart);\r\n    const closestNode = TempStart.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall && closestNode.wallweight == 99999999) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.startvisited = true;\r\n    updateUnvisitedNeighborsStart(\r\n      closestNode,\r\n      grid,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed,\r\n      TempStart,\r\n      closestNode.wallweight\r\n    );\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) {\r\n      //console.log(\"Hello\");\r\n      var temp1 = [closestNode];\r\n      visitedNodesInOrder.unshift(temp1);\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (closestNode.endvisited) {\r\n      // //console.log(\"Hi\");\r\n      var temp2 = [closestNode];\r\n      visitedNodesInOrder.unshift(temp2);\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n\r\n  while (TempEnd.length > 0) {\r\n    // //console.log(\"End side left\");\r\n    sortNodesByDistance(TempEnd);\r\n    const closestNode2 = TempEnd.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode2.isWall && closestNode2.wallweight == 99999999) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode2.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode2.endvisited = true;\r\n    updateUnvisitedNeighborsEnd(\r\n      closestNode2,\r\n      grid,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed,\r\n      TempEnd,\r\n      closestNode2.wallweight\r\n    );\r\n    visitedNodesInOrder.push(closestNode2);\r\n    if (closestNode2 === startNode) {\r\n      //console.log(\"Hello\");\r\n      var temp1 = [closestNode2];\r\n      visitedNodesInOrder.unshift(temp1);\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (closestNode2.startvisited) {\r\n      //console.log(\"Hurrayyyy!!!\");\r\n      var temp2 = [closestNode2];\r\n      visitedNodesInOrder.unshift(temp2);\r\n      return visitedNodesInOrder;\r\n    }\r\n  }\r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighborsEnd(\r\n  node,\r\n  grid,\r\n  finishNode,\r\n  heuristic,\r\n  diagonalallowed,\r\n  TempEnd,\r\n  wallweight\r\n) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, diagonalallowed);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    if (neighbor.endvisited) continue;\r\n    //console.log(finishNode.col);\r\n    //console.log(neighbor.col);\r\n    var value;\r\n    var string = \"Manhattan\";\r\n    var string2 = \"Diagonal\";\r\n    var string3 = \"Euclidean\";\r\n    var string4 = \"Octile\";\r\n    var string5 = \"Chebyshev\";\r\n    if (heuristic.localeCompare(string) == 0) {\r\n      value =\r\n        Math.abs(neighbor.row - finishNode.row) +\r\n        Math.abs(neighbor.col - finishNode.col);\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string2) == 0) {\r\n      value = Math.max(\r\n        Math.abs(neighbor.row - finishNode.row),\r\n        Math.abs(neighbor.col - finishNode.col)\r\n      );\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string3) == 0) {\r\n      value = Math.sqrt(\r\n        Math.pow(neighbor.row - finishNode.row, 2) +\r\n          Math.pow(neighbor.col - finishNode.col, 2)\r\n      );\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string4) == 0) {\r\n      var x_dist = Math.abs(neighbor.row - finishNode.row);\r\n      var y_dist = Math.abs(neighbor.col - finishNode.col);\r\n      value =\r\n        Math.max(x_dist, y_dist) +\r\n        (Math.sqrt(2) - 1) * Math.min(x_dist, y_dist);\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string5) == 0) {\r\n      value = Math.max(\r\n        Math.abs(neighbor.row - finishNode.row),\r\n        Math.abs(neighbor.col - finishNode.col)\r\n      );\r\n      //console.log(value);\r\n    }\r\n    neighbor.next = node;\r\n    // neighbor.previousNode = closestNodeEnd;\r\n    neighbor.endvisited = true;\r\n    neighbor.distance = value + wallweight;\r\n    TempEnd.push(neighbor);\r\n  }\r\n}\r\nfunction updateUnvisitedNeighborsStart(\r\n  node,\r\n  grid,\r\n  finishNode,\r\n  heuristic,\r\n  diagonalallowed,\r\n  TempStart,\r\n  wallweight\r\n) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, diagonalallowed);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    if (neighbor.startvisited) continue;\r\n    //console.log(finishNode.col);\r\n    //console.log(neighbor.col);\r\n    var value;\r\n    var string = \"Manhattan\";\r\n    var string2 = \"Diagonal\";\r\n    var string3 = \"Euclidean\";\r\n    var string4 = \"Octile\";\r\n    var string5 = \"Chebyshev\";\r\n    if (heuristic.localeCompare(string) == 0) {\r\n      value =\r\n        Math.abs(neighbor.row - finishNode.row) +\r\n        Math.abs(neighbor.col - finishNode.col);\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string2) == 0) {\r\n      value = Math.max(\r\n        Math.abs(neighbor.row - finishNode.row),\r\n        Math.abs(neighbor.col - finishNode.col)\r\n      );\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string3) == 0) {\r\n      value = Math.sqrt(\r\n        Math.pow(neighbor.row - finishNode.row, 2) +\r\n          Math.pow(neighbor.col - finishNode.col, 2)\r\n      );\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string4) == 0) {\r\n      var x_dist = Math.abs(neighbor.row - finishNode.row);\r\n      var y_dist = Math.abs(neighbor.col - finishNode.col);\r\n      value =\r\n        Math.max(x_dist, y_dist) +\r\n        (Math.sqrt(2) - 1) * Math.min(x_dist, y_dist);\r\n      //console.log(value);\r\n    } else if (heuristic.localeCompare(string5) == 0) {\r\n      value = Math.max(\r\n        Math.abs(neighbor.row - finishNode.row),\r\n        Math.abs(neighbor.col - finishNode.col)\r\n      );\r\n      //console.log(value);\r\n    }\r\n    neighbor.previousNode = node;\r\n    neighbor.startvisited = true;\r\n    neighbor.distance = value + wallweight;\r\n    TempStart.push(neighbor);\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, diagonalallowed) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (diagonalallowed) {\r\n    if (row > 0 && col > 0) neighbors.push(grid[row - 1][col - 1]);\r\n    if (row > 0 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row - 1][col + 1]);\r\n    if (row < grid.length - 1 && col > 0)\r\n      neighbors.push(grid[row + 1][col - 1]);\r\n    if (row < grid.length - 1 && col < grid[0].length - 1)\r\n      neighbors.push(grid[row + 1][col + 1]);\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nfunction getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function bbfs(grid,startNode,finishNode,diagonalallowed){\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0; finishNode.distance = 0\r\n  const startqueue = [startNode];\r\n  startNode.startvisited = true;\r\n  finishNode.endvisited = true;\r\n  const endqueue = [finishNode];\r\n  while (!!startqueue.length && endqueue.length){\r\n    const closestNode = startqueue.shift();\r\n    if (closestNode.wallweight === 99999999) continue ;\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) {\r\n      var temp1 = [closestNode];\r\n      visitedNodesInOrder.unshift(temp1)\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (closestNode.endvisited){\r\n      var temp2 = [closestNode];\r\n      visitedNodesInOrder.unshift(temp2)\r\n      return visitedNodesInOrder;\r\n    }\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors){\r\n      if (neighbor.startvisited) continue ;\r\n      if (neighbor.endvisited){\r\n        var temp3 = [neighbor];\r\n      neighbor.previousNode = closestNode;\r\n        neighbor.startvisited = true;\r\n        neighbor.distance = closestNode.distance + neighbor.wallweight;\r\n        startqueue.push(neighbor);\r\n      visitedNodesInOrder.unshift(temp3)\r\n      return visitedNodesInOrder;\r\n      }\r\n        neighbor.previousNode = closestNode;\r\n        neighbor.startvisited = true;\r\n        neighbor.distance = closestNode.distance + neighbor.wallweight;\r\n        startqueue.push(neighbor);\r\n    }\r\n\r\n    const ftNode = endqueue.shift();\r\n    if (ftNode.wallweight === 99999999) continue ;\r\n    if (ftNode.distance === Infinity) return visitedNodesInOrder;\r\n    ftNode.isVisited = true;\r\n    visitedNodesInOrder.push(ftNode);\r\n    if (ftNode === startNode) {\r\n      var temp4 = [ftNode];\r\n      visitedNodesInOrder.unshift(temp4)\r\n      return visitedNodesInOrder;\r\n    }\r\n    if (ftNode.startvisited){\r\n      var temp5 = [ftNode];\r\n      visitedNodesInOrder.unshift(temp5)\r\n      return visitedNodesInOrder;\r\n    }\r\n    const unvisitedNeighbor = getUnvisitedNeighbors(ftNode, grid,diagonalallowed);\r\n    for (const neighbora of unvisitedNeighbor){\r\n      if (neighbora.endvisited) continue ;\r\n      if (neighbora.startvisited){\r\n      var temp6 = [neighbora];\r\n      visitedNodesInOrder.unshift(temp6)\r\n      neighbora.nex = ftNode;\r\n      neighbora.endvisited = true;\r\n      neighbora.distance = ftNode.distance + neighbora.wallweight;\r\n      endqueue.push(neighbora);\r\n      return visitedNodesInOrder;\r\n    }\r\n      neighbora.nex = ftNode;\r\n      neighbora.endvisited = true;\r\n      neighbora.distance = ftNode.distance + neighbora.wallweight;\r\n      endqueue.push(neighbora);\r\n    }\r\n  }\r\n  console.log(1)\r\n  while (!!startqueue.length){\r\n    console.log(\"here2\")\r\n    const closestNode = startqueue.shift();\r\n    if (closestNode.wallweight === 99999999) continue ;\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) {\r\n      var temp1 = [closestNode];\r\n      visitedNodesInOrder.unshift(temp1)\r\n      return visitedNodesInOrder;\r\n    }\r\n    // if (closestNode.endvisited){\r\n    //   var temp2 = [closestNode];\r\n    //   visitedNodesInOrder.unshift(temp2)\r\n    //   return visitedNodesInOrder;\r\n    // }\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors){\r\n      if (neighbor.startvisited) continue ;\r\n      // if (neighbor.endvisited){\r\n      //   var temp3 = [neighbor];\r\n      // neighbor.previousNode = closestNode;\r\n      //   neighbor.startvisited = true;\r\n      //   neighbor.distance = closestNode.distance + neighbor.wallweight;\r\n      //   startqueue.push(neighbor);\r\n      // visitedNodesInOrder.unshift(temp3)\r\n      // return visitedNodesInOrder;\r\n      // }\r\n        neighbor.previousNode = closestNode;\r\n        neighbor.startvisited = true;\r\n        neighbor.distance = closestNode.distance + neighbor.wallweight;\r\n        startqueue.push(neighbor);\r\n    }\r\n  }\r\n  while(!!endqueue.length){\r\n    console.log(\"here3\")\r\n    const ftNode = endqueue.shift();\r\n    if (ftNode.wallweight > 99999998) continue ;\r\n    if (ftNode.distance === Infinity) return visitedNodesInOrder;\r\n    ftNode.isVisited = true;\r\n    visitedNodesInOrder.push(ftNode);\r\n    // if (ftNode === startNode) {\r\n    //   var temp4 = [ftNode];\r\n    //   visitedNodesInOrder.unshift(temp4)\r\n    //   return visitedNodesInOrder;\r\n    // }\r\n    if (ftNode.startvisited){\r\n      var temp5 = [ftNode];\r\n      visitedNodesInOrder.unshift(temp5)\r\n      return visitedNodesInOrder;\r\n    }\r\n    const unvisitedNeighbor = getUnvisitedNeighbors(ftNode, grid,diagonalallowed);\r\n    for (const neighbora of unvisitedNeighbor){\r\n      if (neighbora.endvisited) continue ;\r\n    //   if (neighbora.startvisited){\r\n    //   var temp6 = [neighbora];\r\n    //   visitedNodesInOrder.unshift(temp6)\r\n    //   neighbora.nex = ftNode;\r\n    //   neighbora.endvisited = true;\r\n    //   neighbora.distance = ftNode.distance + neighbora.wallweight;\r\n    //   endqueue.push(neighbora);\r\n    //   return visitedNodesInOrder;\r\n    // }\r\n      neighbora.nex = ftNode;\r\n      neighbora.endvisited = true;\r\n      neighbora.distance = ftNode.distance + neighbora.wallweight;\r\n      endqueue.push(neighbora);\r\n    }\r\n  }\r\n  console.log(\"here1\")\r\n  var temp = [finishNode]\r\n  visitedNodesInOrder.unshift(temp)\r\n  return visitedNodesInOrder \r\n}\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (diagonalallowed){\r\n    if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n    if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n    if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n    if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n    \r\n  }\r\n  return neighbors\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function bibfsans(node) {\r\n  // return [node];\r\n  var ans = []\r\n  let s = node ;  let e = node\r\n  while (s.previousNode !== null && e.nex !== null){\r\n    ans.unshift(s.previousNode);\r\n    ans.unshift(e.nex)\r\n    s = s.previousNode;\r\n    e = e.nex ;\r\n  }\r\n  while (s.previousNode !== null){\r\n    ans.unshift(s.previousNode);\r\n    s = s.previousNode;\r\n  }\r\n  while (e.nex !== null){\r\n    ans.unshift(e.nex);\r\n    e = e.nex ;\r\n  }\r\n  ans.push(node)\r\n  return ans\r\n}","//My variation of A star algorithm\r\nimport _ from \"lodash\" ;\r\nexport function BiIastar(grid, startNode, finishNode,heuristic,diagonalallowed) {\r\n    const visitedNodesInOrder = []; //closed list\r\n    const TempEnd=[];\r\n    const TempStart=[];\r\n    const tempstart = _.cloneDeep(startNode);\r\n    tempstart.distance=0;\r\n    const tempend = _.cloneDeep(finishNode);\r\n    tempend.distance=0;\r\n    TempStart.push(tempstart);\r\n    TempEnd.push(tempend);\r\n    while (TempStart.length>0 && TempEnd.length>0) {\r\n      sortNodesByDistance(TempStart);\r\n      const closestNode = TempStart.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall && closestNode.wallweight==999999) \r\n      {\r\n        continue;\r\n      }\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.startvisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      updateUnvisitedNeighborsStart(closestNode, grid,finishNode,heuristic,diagonalallowed,TempStart,closestNode.wallweight);\r\n        if(closestNode === finishNode) \r\n        {\r\n      console.log(\"Hello\");\r\n        var temp1 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp1)\r\n        return visitedNodesInOrder;\r\n        }\r\n        if (closestNode.endvisited)\r\n        {\r\n        // console.log(\"Hi\");\r\n        var temp2 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp2)\r\n        return visitedNodesInOrder;\r\n        }\r\n\r\n        sortNodesByDistance(TempEnd);\r\n      const closestNode2 = TempEnd.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode2.isWall && closestNode2.wallweight==999999) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode2.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode2.endvisited = true;\r\n      updateUnvisitedNeighborsEnd(closestNode2, grid,finishNode,heuristic,diagonalallowed,TempEnd,closestNode2.wallweight);\r\n      visitedNodesInOrder.push(closestNode2);  \r\n      if(closestNode2 === startNode) \r\n        {\r\n      console.log(\"Hello\");\r\n        var temp1 = [closestNode2];\r\n        visitedNodesInOrder.unshift(temp1)\r\n        return visitedNodesInOrder;\r\n        }\r\n        if (closestNode2.startvisited)\r\n        {\r\n        // console.log(\"Hi\");\r\n        var temp2 = [closestNode2];\r\n        visitedNodesInOrder.unshift(temp2)\r\n        return visitedNodesInOrder;\r\n        }\r\n    }\r\n    while(TempStart.length>0)\r\n    {\r\n        sortNodesByDistance(TempStart);\r\n      const closestNode = TempStart.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall && closestNode.wallweight==999999) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.startvisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      updateUnvisitedNeighborsStart(closestNode, grid,finishNode,heuristic,diagonalallowed,TempStart,closestNode.wallweight);\r\n        if(closestNode === finishNode) \r\n        {\r\n      console.log(\"Hello\");\r\n        var temp1 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp1)\r\n        return visitedNodesInOrder;\r\n        }\r\n        if (closestNode.endvisited)\r\n        {\r\n        // console.log(\"Hi\");\r\n        var temp2 = [closestNode];\r\n        visitedNodesInOrder.unshift(temp2)\r\n        return visitedNodesInOrder;\r\n        }\r\n    }\r\n    while(TempEnd.length>0)\r\n    {\r\n        sortNodesByDistance(TempEnd);\r\n        const closestNode2 = TempEnd.shift();\r\n        // If we encounter a wall, we skip it.\r\n        if (closestNode2.isWall && closestNode2.wallweight==999999) continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (closestNode2.distance === Infinity) return visitedNodesInOrder;\r\n        closestNode2.endvisited = true;\r\n        updateUnvisitedNeighborsEnd(closestNode2, grid,finishNode,heuristic,diagonalallowed,TempEnd,closestNode2.wallweight);\r\n        visitedNodesInOrder.push(closestNode2);  \r\n        if(closestNode2 === startNode) \r\n          {\r\n        console.log(\"Hello\");\r\n          var temp1 = [closestNode2];\r\n          visitedNodesInOrder.unshift(temp1)\r\n          return visitedNodesInOrder;\r\n          }\r\n          if (closestNode2.startvisited)\r\n          {\r\n          // console.log(\"Hi\");\r\n          var temp2 = [closestNode2];\r\n          visitedNodesInOrder.unshift(temp2)\r\n          return visitedNodesInOrder;\r\n          }\r\n    }\r\n}\r\n  \r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighborsStart(node, grid,finishNode,heuristic,diagonalallowed,TempStart,wallweight) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        if (neighbor.startvisited) continue ;\r\n      console.log(finishNode.col);\r\n      console.log(neighbor.col);\r\n      var value;\r\n      var string=\"Manhattan\";\r\n      var string2=\"Diagonal\";\r\n      var string3=\"Euclidean\";\r\n      var string4=\"Octile\";\r\n      var string5=\"Chebyshev\";\r\n      if(heuristic.localeCompare(string)==0)\r\n      {\r\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string2)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string3)==0)\r\n      {\r\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string4)==0)\r\n      {\r\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\r\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\r\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string5)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      var temp= node.distance + wallweight*value;\r\n      neighbor.distance=temp;\r\n      neighbor.previousNode = node;\r\n          neighbor.startvisited = true;\r\n          TempStart.push(neighbor);\r\n    }\r\n  }\r\n  \r\n  function updateUnvisitedNeighborsEnd(node, grid,finishNode,heuristic,diagonalallowed,TempEnd,wallweight) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n        if (neighbor.endvisited) continue ;\r\n      console.log(finishNode.col);\r\n      console.log(neighbor.col);\r\n      var value;\r\n      var string=\"Manhattan\";\r\n      var string2=\"Diagonal\";\r\n      var string3=\"Euclidean\";\r\n      var string4=\"Octile\";\r\n      var string5=\"Chebyshev\";\r\n      if(heuristic.localeCompare(string)==0)\r\n      {\r\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string2)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string3)==0)\r\n      {\r\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string4)==0)\r\n      {\r\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\r\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\r\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string5)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      var temp= node.distance + value*wallweight;\r\n      neighbor.distance=temp;\r\n      neighbor.next=node; \r\n    // neighbor.previousNode = closestNodeEnd;\r\n     neighbor.endvisited = true;\r\n     TempEnd.push(neighbor);\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (diagonalallowed){\r\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n      \r\n    }\r\n    return neighbors;\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n  ","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode,diagonalallowed) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (unvisitedNodes.length>0) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall && closestNode.wallweight==99999999) \r\n    {\r\n      console.log(closestNode.wallweight);\r\n      continue;\r\n    }\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode) return visitedNodesInOrder;\r\n    updateUnvisitedNeighbors(closestNode, grid,diagonalallowed,closestNode.wallweight);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid,diagonalallowed,wallweight) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + wallweight;\r\n    neighbor.previousNode = node;\r\n    neighbor.isVisited=true;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (diagonalallowed){\r\n    if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n    if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n    if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n    if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n    \r\n  }\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","//My variation of A star algorithm\r\nexport function Iastar(grid, startNode, finishNode,heuristic,diagonalallowed) {\r\n    const visitedNodesInOrder = []; //closed list\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid); //open list\r\n    while (unvisitedNodes.length>0) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall && closestNode.wallweight==999999)\r\n      { \r\n        continue;\r\n      }\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid,finishNode,heuristic,diagonalallowed,closestNode.wallweight);\r\n    }\r\n  }\r\n  \r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(node, grid,finishNode,heuristic,diagonalallowed,wallweight) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      console.log(finishNode.col);\r\n      console.log(neighbor.col);\r\n      var value;\r\n      var string=\"Manhattan\";\r\n      var string2=\"Diagonal\";\r\n      var string3=\"Euclidean\";\r\n      var string4=\"Octile\";\r\n      var string5=\"Chebyshev\";\r\n      if(heuristic.localeCompare(string)==0)\r\n      {\r\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string2)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string3)==0)\r\n      {\r\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string4)==0)\r\n      {\r\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\r\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\r\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string5)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      neighbor.distance=value*wallweight+node.distance;\r\n      neighbor.previousNode = node;\r\n      neighbor.isVisited=true;\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (diagonalallowed){\r\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n      \r\n    }\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n  ","//Original implementation of Best First Search\r\nexport function IBestfs(grid, startNode, finishNode,heuristic,diagonalallowed) {\r\n    const visitedNodesInOrder = []; //closed list\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = []; //open list\r\n    unvisitedNodes.push(startNode);\r\n    while (unvisitedNodes.length>0) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall && closestNode.wallweight==99999999) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) \r\n      {\r\n        visitedNodesInOrder.push(closestNode);\r\n        return visitedNodesInOrder;\r\n      }   \r\n      updateUnvisitedNeighbors(closestNode, grid,finishNode,unvisitedNodes,heuristic,diagonalallowed,closestNode.wallweight);\r\n    }\r\n  }\r\n  \r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(node, grid,finishNode,unvisitedNodes,heuristic,diagonalallowed,wallweight) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid,diagonalallowed);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      console.log(finishNode.col);\r\n      console.log(neighbor.col);\r\n      var value;\r\n      var string=\"Manhattan\";\r\n      var string2=\"Diagonal\";\r\n      var string3=\"Euclidean\";\r\n      var string4=\"Octile\";\r\n      var string5=\"Chebyshev\";\r\n      if(heuristic.localeCompare(string)==0)\r\n      {\r\n        value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string2)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string3)==0)\r\n      {\r\n        value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string4)==0)\r\n      {\r\n        var x_dist=Math.abs(neighbor.row-finishNode.row);\r\n        var y_dist=Math.abs(neighbor.col-finishNode.col);\r\n        value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\r\n        console.log(value);\r\n      }\r\n      else if(heuristic.localeCompare(string5)==0)\r\n      {\r\n        value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n        console.log(value);\r\n      }\r\n      neighbor.distance=wallweight*value;\r\n      neighbor.previousNode = node;\r\n      neighbor.isVisited = true;\r\n      unvisitedNodes.push(neighbor);\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (diagonalallowed){\r\n      if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n      if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n      if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n      if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n      \r\n    }\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }\r\n  ","export function IDAstar(grid, startNode, finishNode,heuristic,diagonalallowed) {\r\n    var depth=1;\r\n    while(1)\r\n    {\r\n        //console.log(\"Hello\");\r\n        var i=0;\r\n        getAllNodes(grid);\r\n        const visitedNodesInOrder = [];\r\n        var unvisitedNodes = []\r\n        startNode.distance = 0;\r\n        unvisitedNodes.push(startNode);\r\n        //console.log(startNode);\r\n        //console.log(\"Pushed\");\r\n        //console.log(visitedNodesInOrder);\r\n        while(i<depth)\r\n        {\r\n            //console.log(visitedNodesInOrder);\r\n            //visitedNodesInOrder.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n            //console.log(visitedNodesInOrder);\r\n            //console.log(visitedNodesInOrder);\r\n            if(unvisitedNodes.length==0)\r\n            {\r\n                console.log(\"Path not found\");\r\n                return visitedNodesInOrder;\r\n            }\r\n            sortNodesByDistance(unvisitedNodes);\r\n            const closestNode = unvisitedNodes.shift();\r\n            if (closestNode.isWall && closestNode.wallweight==99999999) continue;\r\n            // If the closest node is at a distance of infinity,\r\n            // we must be trapped and should therefore stop.\r\n            if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n            if(closestNode === finishNode)\r\n            {\r\n                visitedNodesInOrder.push(finishNode)\r\n                return visitedNodesInOrder\r\n            }    \r\n            //console.log(closestNode);\r\n            closestNode.isVisited=true;\r\n            visitedNodesInOrder.push(closestNode);\r\n            const unvisitedNeighbors = getUnvisitedNeighbors(closestNode, grid,diagonalallowed);\r\n            //console.log(unvisitedNeighbors);\r\n            for (const neighbor of unvisitedNeighbors) {\r\n                var value;\r\n                var string=\"Manhattan\";\r\n                var string2=\"Diagonal\";\r\n                var string3=\"Euclidean\";\r\n                var string4=\"Octile\";\r\n                var string5=\"Chebyshev\";\r\n                if(heuristic.localeCompare(string)==0)\r\n                {\r\n                    value=Math.abs(neighbor.row-finishNode.row)+Math.abs(neighbor.col-finishNode.col);\r\n                    //console.log(value);\r\n                }\r\n                else if(heuristic.localeCompare(string2)==0)\r\n                {\r\n                    value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n                    //console.log(value);\r\n                }\r\n                else if(heuristic.localeCompare(string3)==0)\r\n                {\r\n                    value=Math.sqrt(Math.pow((neighbor.row-finishNode.row),2)+Math.pow((neighbor.col-finishNode.col),2));\r\n                    //console.log(value);\r\n                }\r\n                else if(heuristic.localeCompare(string4)==0)\r\n                {\r\n                    var x_dist=Math.abs(neighbor.row-finishNode.row);\r\n                    var y_dist=Math.abs(neighbor.col-finishNode.col);\r\n                    value=Math.max(x_dist,y_dist)+(Math.sqrt(2)-1) * Math.min(x_dist,y_dist);\r\n                    //console.log(value);\r\n                }\r\n                else if(heuristic.localeCompare(string5)==0)\r\n                {\r\n                    value=Math.max(Math.abs(neighbor.row-finishNode.row),Math.abs(neighbor.col-finishNode.col));\r\n                    //console.log(value);\r\n                }\r\n                neighbor.distance = value+closestNode.wallweight;\r\n                neighbor.previousNode = closestNode;\r\n                neighbor.isVisited = true;\r\n                unvisitedNodes.push(neighbor);\r\n                //console.log(neighbor);\r\n                //console.log(visitedNodesInOrder);\r\n                //console.log(depth);\r\n                if (neighbor === finishNode)\r\n                { \r\n                    visitedNodesInOrder.push(finishNode);\r\n                    return visitedNodesInOrder;\r\n                }    \r\n            }\r\n            i=i+1;\r\n        \r\n        }\r\n    depth=depth+1;\r\n    }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  \r\n  function getUnvisitedNeighbors(node, grid,diagonalallowed) {\r\n    const neighbors = [];\r\n    //console.log(node);\r\n    const col=node.col;\r\n    const row=node.row;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    if (diagonalallowed){\r\n        if (row > 0 && col > 0) neighbors.push(grid[row-1][col-1]);\r\n        if (row > 0 && col < grid[0].length - 1) neighbors.push(grid[row-1][col+1]);\r\n        if (row <  grid.length - 1 && col > 0 ) neighbors.push(grid[row+1][col-1]);\r\n        if (row <  grid.length - 1 && col < grid[0].length - 1) neighbors.push(grid[row+1][col+1]);\r\n        \r\n      }\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  \r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n","var Heap = require('heap');\r\nfunction heurestics(a,b,h){\r\n    if (h === 1){\r\n        // Euclidean\r\n       return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\r\n    }\r\n    if (h === 2){\r\n        // Manhattan\r\n        return b.row - a.row + b.col - a.col\r\n    }\r\n    if (h === 3){\r\n        // octile\r\n        var a = Math.sqrt(2) - 1\r\n        var dx = b.row - a.row \r\n        var dy = b.col - a.col\r\n        return dx + dy + (a- 2)*Math.min(dx,dy)\r\n\r\n    }\r\n    if (h === 4){\r\n        // chebyshev\r\n        var dx = b.row - a.row \r\n        var dy = b.col - a.col\r\n        return Math.max(dx,dy)\r\n    }\r\n}\r\nfunction dblock(cX,cY,dX,dY,grid){\r\n    if (grid[cX-dX][cY].wallweight > 99999998 && grid[cX][cY-dY].wallweight > 99999998){\r\n        return true\r\n    }\r\n    return false\r\n}\r\nfunction blocked(cX,cY,dX,dY,grid){\r\n    // console.log(\"check blocked\",cX,cY,dX,dY)\r\n    if (cX + dX < 0 || cX +dX >= grid.length){\r\n        return true\r\n    }\r\n    if (cY +dY <0 || cY +dY >= grid[0].length){\r\n        return true\r\n    }\r\n    if (dX !== 0 && dY !== 0){\r\n        if (grid[cX + dX][cY].wallweight > 99999998&& grid[cX][cY+dY].wallweight > 99999998){\r\n            return true\r\n        }\r\n        if (grid[cX + dX][cY + dY].wallweight > 99999998){\r\n            return true\r\n        }\r\n    }\r\n    else{\r\n        if (dX !== 0){\r\n            if (grid[cX+dX][cY].wallweight > 99999998){\r\n                return true\r\n            }\r\n        }\r\n        else{\r\n            if (grid[cX][cY+dY].wallweight > 99999998){\r\n                return true\r\n            }\r\n        }\r\n    }\r\n    return false\r\n}\r\nfunction direction(a,b){\r\n    var dX = Math.sign(a.row-b.row)\r\n    var dY = Math.sign(a.col-b.col)\r\n    if (a.row-b.row === 0){\r\n        dX = 0\r\n    }\r\n    if (a.col-b.col === 0){\r\n        dY = 0\r\n    }\r\n    return [dX,dY]\r\n}\r\nfunction nodeNeighbors(node,parent,grid){\r\n    var neighbors = []\r\n    var cX = node.row ; var cY = node.col\r\n    if (parent == null){\r\n        var temp = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\r\n        for (var i = 0 ; i< 8 ; i++){\r\n            var r = temp[i][0]\r\n            var c = temp[i][1]\r\n            if (!blocked(cX,cY,r,c,grid)){\r\n                neighbors.push(grid[cX+r][cY+c])\r\n            }\r\n        }\r\n        return neighbors\r\n    }\r\n    var x = direction(node,parent)\r\n    var dX = x[0] ; var dY = x[1];\r\n    if (dX !== 0 && dY !== 0){\r\n        if (!blocked(cX,cY,0,dY,grid)){\r\n            neighbors.push(grid[cX][cY+dY])\r\n        }\r\n        if (!blocked(cX,cY,dX,0,grid)){\r\n            neighbors.push(grid[cX+dX][cY])\r\n        }\r\n        if ((!blocked(cX, cY, 0, dY, grid) || !blocked(cX, cY, dX, 0, grid)) && (!blocked(cX, cY, dX, dY, grid))){\r\n            neighbors.push(grid[cX+dX][cY+dY])\r\n        }\r\n        if (blocked(cX, cY, -dX, 0, grid) && !blocked(cX, cY, 0, dY, grid) && !blocked(cX, cY, -dX, dY, grid)){\r\n            neighbors.push(grid[cX-dX][cY+dY])\r\n        }\r\n        if (blocked(cX, cY, 0, -dY, grid) && !blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, -dY, grid)){\r\n            neighbors.push(grid[cX+dX][cY-dY])\r\n        }\r\n    }\r\n    else{\r\n        if (dX === 0){\r\n            if (!blocked(cX, cY, dX, 0, grid)){\r\n                if (!blocked(cX, cY, 0, dY, grid)){\r\n                    neighbors.push(grid[cX][cY+dY])\r\n                }\r\n                if (blocked(cX, cY, 1, 0, grid) && !blocked(cX, cY, 1, dY, grid)){\r\n                    neighbors.push(grid[cX+1][cY+dY])\r\n                }\r\n                if (blocked(cX, cY, -1, 0, grid) && !blocked(cX, cY, -1, dY, grid)){\r\n                    neighbors.push(grid[cX-1][cY+dY])\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            if (!blocked(cX, cY, dX, 0, grid)){\r\n                if (!blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, 0, grid)){\r\n                    neighbors.push(grid[cX+dX][cY])\r\n                }\r\n                if (blocked(cX, cY, 0, 1, grid) && !blocked(cX, cY, dX, 1, grid)){\r\n                    neighbors.push(grid[cX+dX][cY+1])\r\n                }\r\n                if (blocked(cX, cY, 0, -1, grid) && !blocked(cX, cY, dX, -1, grid)){\r\n                    neighbors.push(grid[cX+dX][dY-1])\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return neighbors\r\n}\r\nfunction identifySuccessors(node,grid,finishNode){\r\n    var successors = []\r\n    var neighbors = nodeNeighbors(node,node.previousNode,grid)\r\n    for (var i = 0; i<neighbors.length;i++){\r\n        var neighbor = neighbors[i]\r\n        if (neighbor){\r\n            console.log(neighbor)\r\n            var dX = neighbor.row - node.row\r\n            var dY = neighbor.col - node.col\r\n            var jumpPoint = jump(node.row,node.col,dX,dY,grid,finishNode)\r\n            if (jumpPoint){\r\n                successors.push(jumpPoint)\r\n            }\r\n        }\r\n    }\r\n    return successors\r\n}\r\nfunction length(curr,jumpPoint,h){\r\n    return heurestics(curr,jumpPoint,h)\r\n}\r\nfunction jump(cX,cY,dX,dY,grid,finishNode){\r\n    var nX = cX + dX; var nY = cY + dY\r\n    if (blocked(nX, nY, 0, 0, grid)){\r\n        return\r\n    }\r\n    if (grid[nX][nY] === finishNode){\r\n        return finishNode;\r\n    }\r\n    var oX = nX ; var oY = nY\r\n    if (dX !== 0 && dY !== 0){\r\n        while (true){\r\n            if ((!blocked(oX, oY, -dX, dY, grid) && blocked(oX, oY, -dX, 0, grid)) || (!blocked(oX, oY, dX, -dY, grid) && blocked(oX, oY, 0, -dY, grid))){\r\n                return grid[oX][oY]\r\n            }\r\n            if (jump(oX, oY, dX, 0, grid, finishNode) || jump(oX, oY, 0, dY, grid, finishNode)){\r\n                return grid[oX][oY]\r\n            }\r\n            oX = oX + dX;\r\n            oY = oY + dY;\r\n            if (blocked(oX, oY, 0, 0, grid)){\r\n                return\r\n            }\r\n            if (dblock(oX, oY, dX, dY, grid)){\r\n                return \r\n            }\r\n            if (grid[oX][oY] === finishNode){\r\n                return finishNode\r\n            }\r\n        }\r\n    }\r\n    else{\r\n        if (dX !== 0){\r\n            while (true){\r\n                if ((!blocked(oX, nY, dX, 1, grid) && blocked(oX, nY, 0, 1, grid)) || (!blocked(oX, nY, dX, -1, grid) && blocked(oX, nY, 0, -1, grid))){\r\n                    return grid[oX][nY]\r\n                }\r\n                oX = oX + dX\r\n                if (blocked(oX, nY, 0, 0, grid)){\r\n                    return\r\n                }\r\n                if (grid[oX][nY] === finishNode){\r\n                    return finishNode\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            while (true){\r\n                if ((!blocked(nX, oY, 1, dY, grid) && blocked(nX, oY, 1, 0, grid)) || (!blocked(nX, oY, -1, dY, grid) && blocked(nX, oY, -1, 0, grid))){\r\n                    return grid[nX][oY]\r\n                }\r\n                oY = oY + dY\r\n                if (blocked(nX, oY, 0, 0, grid)){\r\n                    return\r\n                }\r\n                if (grid[nX][oY] === finishNode){\r\n                    return finishNode\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n    return jump(nX, nY, dX, dY, grid, finishNode)\r\n}\r\nexport function jps(grid,startNode,finishNode,h){\r\n    var openList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\r\n    startNode.gscore = 0 ;\r\n    startNode.fscore = 0 ; \r\n    openList.push(startNode);\r\n    startNode.inopen = true;\r\n    const visitedNodesInOrder = [];\r\n    while (!openList.empty()){\r\n        var node = openList.pop();\r\n        node.inclosed = true;\r\n        visitedNodesInOrder.push(node)\r\n        if (node === finishNode){\r\n            return visitedNodesInOrder;\r\n        }\r\n        var successors = identifySuccessors(node,grid,finishNode);\r\n        for (var i = 0 ;i < successors.length;i++){\r\n            var successor = successors[i];\r\n            if (!successor.inclosed){\r\n                var val = node.gscore + length(node,successor,h)\r\n                if (!successor.inopen || val < successor.gscore){\r\n                    successor.gscore = val;\r\n                    successor.hscore = heurestics(successor,finishNode,h)\r\n                    successor.fscore = successor.gscore + successor.hscore*successor.wallweight\r\n                    successor.previousNode = node\r\n                    if (!successor.inopen){\r\n                        openList.push(successor)\r\n                        successor.inopen = true\r\n                    }\r\n                    else{\r\n                        openList.updateItem(successor)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder\r\n}\r\nexport function jpsans(finishNode,grid,h){\r\n    var curr = finishNode\r\n    const nodesInShortestPathOrder = [];\r\n    while (curr !== null){\r\n        if (curr.previousNode){\r\n            var parent = curr.previousNode\r\n            var direc = direction(curr,parent)\r\n            var dX = direc[0] ; var dY = direc[1]\r\n            if ((dX === 0 && dY !== 0)|| (dY === 0 && dX !== 0)){\r\n                if (dY === 1){\r\n                    if (parent.col < curr.col){\r\n                        for (var a = parent.col + 1 ; a<curr.col ; a++){\r\n                            nodesInShortestPathOrder.push(grid[curr.row][a])\r\n                        }\r\n                    }\r\n                    else if (parent.col > curr.col){\r\n                        for (var b = parent.col ; b > curr.col ; b--){\r\n                            nodesInShortestPathOrder.push(grid[curr.row][b])\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    if (parent.row < curr.row){\r\n                        for (var c = parent.row + 1 ; c<curr.row ; c++){\r\n                            nodesInShortestPathOrder.push(grid[c][curr.col])\r\n                        }\r\n                    }\r\n                    else if (parent.row > curr.row){\r\n                        for (var d = parent.row  ; d > curr.row ; d--){\r\n                            nodesInShortestPathOrder.push(grid[d][curr.col])\r\n                        }\r\n                    }\r\n                }\r\n                nodesInShortestPathOrder.push(curr);\r\n                curr = curr.previousNode;\r\n            }\r\n            else{\r\n                if (parent.row < curr.row){\r\n                    var diff = parent.col - parent.row;\r\n                    for (var j = parent.row ; j < curr.row+1 ;j++){\r\n                        nodesInShortestPathOrder.push(grid[j][j+diff])\r\n                    }\r\n                }\r\n                if (parent.row > curr.row ){\r\n                    var diff = parent.col - parent.row;\r\n                    for (var l = parent.row ; l > curr.row+1 ;l++){\r\n                        nodesInShortestPathOrder.push(grid[l][l+diff])\r\n                    }\r\n                }\r\n                curr = curr.previousNode;\r\n            }\r\n        }\r\n        else{\r\n            nodesInShortestPathOrder.push(curr)\r\n            curr = curr.previousNode\r\n        }\r\n    \r\n    }\r\n    return nodesInShortestPathOrder\r\n\r\n}\r\n\r\n","var Heap = require('heap');\r\nfunction heurestics(a,b,h){\r\n    if (h === 1){\r\n        // Euclidean\r\n       return Math.sqrt((b.row - a.row) ** 2 + (b.col - a.col) ** 2)\r\n    }\r\n    if (h === 2){\r\n        // Manhattan\r\n        return b.row - a.row + b.col - a.col\r\n    }\r\n    if (h === 3){\r\n        // octile\r\n        var a = Math.sqrt(2) - 1\r\n        var dx = b.row - a.row \r\n        var dy = b.col - a.col\r\n        return dx + dy + (a- 2)*Math.min(dx,dy)\r\n\r\n    }\r\n    if (h === 4){\r\n        // chebyshev\r\n        var dx = b.row - a.row \r\n        var dy = b.col - a.col\r\n        return Math.max(dx,dy)\r\n    }\r\n}\r\nfunction dblock(cX,cY,dX,dY,grid){\r\n    if (grid[cX-dX][cY].wallweight > 99999998 && grid[cX][cY-dY].wallweight > 99999998){\r\n        return true\r\n    }\r\n    return false\r\n}\r\nfunction blocked(cX,cY,dX,dY,grid){\r\n    // console.log(\"check blocked\",cX,cY,dX,dY)\r\n    if (cX + dX < 0 || cX +dX >= grid.length){\r\n        return true\r\n    }\r\n    if (cY +dY <0 || cY +dY >= grid[0].length){\r\n        return true\r\n    }\r\n    if (dX !== 0 && dY !== 0){\r\n        if (grid[cX + dX][cY].wallweight > 99999998 && grid[cX][cY+dY].wallweight > 99999998){\r\n            return true\r\n        }\r\n        if (grid[cX + dX][cY + dY].wallweight > 99999998){\r\n            return true\r\n        }\r\n    }\r\n    else{\r\n        if (dX !== 0){\r\n            if (grid[cX+dX][cY].wallweight > 99999998){\r\n                return true\r\n            }\r\n        }\r\n        else{\r\n            if (grid[cX][cY+dY].wallweight > 99999998){\r\n                return true\r\n            }\r\n        }\r\n    }\r\n    return false\r\n}\r\nfunction direction(a,b){\r\n    var dX = Math.sign(a.row-b.row)\r\n    var dY = Math.sign(a.col-b.col)\r\n    if (a.row-b.row === 0){\r\n        dX = 0\r\n    }\r\n    if (a.col-b.col === 0){\r\n        dY = 0\r\n    }\r\n    return [dX,dY]\r\n}\r\nfunction nodeNeighbors(node,parent,grid){\r\n    var neighbors = []\r\n    var cX = node.row ; var cY = node.col\r\n    if (parent == null){\r\n        var temp = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\r\n        for (var i = 0 ; i< 8 ; i++){\r\n            var r = temp[i][0]\r\n            var c = temp[i][1]\r\n            if (!blocked(cX,cY,r,c,grid)){\r\n                neighbors.push(grid[cX+r][cY+c])\r\n            }\r\n        }\r\n        return neighbors\r\n    }\r\n    var x = direction(node,parent)\r\n    var dX = x[0] ; var dY = x[1];\r\n    if (dX !== 0 && dY !== 0){\r\n        if (!blocked(cX,cY,0,dY,grid)){\r\n            neighbors.push(grid[cX][cY+dY])\r\n        }\r\n        if (!blocked(cX,cY,dX,0,grid)){\r\n            neighbors.push(grid[cX+dX][cY])\r\n        }\r\n        if ((!blocked(cX, cY, 0, dY, grid) || !blocked(cX, cY, dX, 0, grid)) && (!blocked(cX, cY, dX, dY, grid))){\r\n            neighbors.push(grid[cX+dX][cY+dY])\r\n        }\r\n        if (blocked(cX, cY, -dX, 0, grid) && !blocked(cX, cY, 0, dY, grid) && !blocked(cX, cY, -dX, dY, grid)){\r\n            neighbors.push(grid[cX-dX][cY+dY])\r\n        }\r\n        if (blocked(cX, cY, 0, -dY, grid) && !blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, -dY, grid)){\r\n            neighbors.push(grid[cX+dX][cY-dY])\r\n        }\r\n    }\r\n    else{\r\n        if (dX === 0){\r\n            if (!blocked(cX, cY, dX, 0, grid)){\r\n                if (!blocked(cX, cY, 0, dY, grid)){\r\n                    neighbors.push(grid[cX][cY+dY])\r\n                }\r\n                if (blocked(cX, cY, 1, 0, grid) && !blocked(cX, cY, 1, dY, grid)){\r\n                    neighbors.push(grid[cX+1][cY+dY])\r\n                }\r\n                if (blocked(cX, cY, -1, 0, grid) && !blocked(cX, cY, -1, dY, grid)){\r\n                    neighbors.push(grid[cX-1][cY+dY])\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            if (!blocked(cX, cY, dX, 0, grid)){\r\n                if (!blocked(cX, cY, dX, 0, grid) && !blocked(cX, cY, dX, 0, grid)){\r\n                    neighbors.push(grid[cX+dX][cY])\r\n                }\r\n                if (blocked(cX, cY, 0, 1, grid) && !blocked(cX, cY, dX, 1, grid)){\r\n                    neighbors.push(grid[cX+dX][cY+1])\r\n                }\r\n                if (blocked(cX, cY, 0, -1, grid) && !blocked(cX, cY, dX, -1, grid)){\r\n                    neighbors.push(grid[cX+dX][dY-1])\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return neighbors\r\n}\r\nfunction identifySuccessors(node,grid,finishNode){\r\n    var successors = []\r\n    var neighbors = nodeNeighbors(node,node.previousNode,grid)\r\n    for (var i = 0; i<neighbors.length;i++){\r\n        var neighbor = neighbors[i]\r\n        if (neighbor){\r\n            // console.log(neighbor)\r\n            var dX = neighbor.row - node.row\r\n            var dY = neighbor.col - node.col\r\n            var jumpPoint = jump(node.row,node.col,dX,dY,grid,finishNode)\r\n            if (jumpPoint){\r\n                successors.push(jumpPoint)\r\n            }\r\n        }\r\n    }\r\n    return successors\r\n}\r\nfunction length(curr,jumpPoint,h){\r\n    return heurestics(curr,jumpPoint,h)\r\n}\r\nfunction jump(cX,cY,dX,dY,grid,finishNode,h){\r\n    var nX = cX + dX; var nY = cY + dY\r\n    if (blocked(nX, nY, 0, 0, grid)){\r\n        return\r\n    }\r\n    if (grid[nX][nY] === finishNode){\r\n        return finishNode;\r\n    }\r\n    var oX = nX ; var oY = nY\r\n    if (dX !== 0 && dY !== 0){\r\n        while (true){\r\n            if ((!blocked(oX, oY, -dX, dY, grid) && blocked(oX, oY, -dX, 0, grid)) || (!blocked(oX, oY, dX, -dY, grid) && blocked(oX, oY, 0, -dY, grid))){\r\n                return grid[oX][oY]\r\n            }\r\n            if (jump(oX, oY, dX, 0, grid, finishNode) || jump(oX, oY, 0, dY, grid, finishNode)){\r\n                return grid[oX][oY]\r\n            }\r\n            oX = oX + dX;\r\n            oY = oY + dY;\r\n            if (blocked(oX, oY, 0, 0, grid)){\r\n                return\r\n            }\r\n            if (dblock(oX, oY, dX, dY, grid)){\r\n                return \r\n            }\r\n            if (grid[oX][oY] === finishNode){\r\n                return finishNode\r\n            }\r\n        }\r\n    }\r\n    else{\r\n        if (dX !== 0){\r\n            while (true){\r\n                if ((!blocked(oX, nY, dX, 1, grid) && blocked(oX, nY, 0, 1, grid)) || (!blocked(oX, nY, dX, -1, grid) && blocked(oX, nY, 0, -1, grid))){\r\n                    return grid[oX][nY]\r\n                }\r\n                oX = oX + dX\r\n                if (blocked(oX, nY, 0, 0, grid)){\r\n                    return\r\n                }\r\n                if (grid[oX][nY] === finishNode){\r\n                    return finishNode\r\n                }\r\n            }\r\n        }\r\n        else{\r\n            while (true){\r\n                if ((!blocked(nX, oY, 1, dY, grid) && blocked(nX, oY, 1, 0, grid)) || (!blocked(nX, oY, -1, dY, grid) && blocked(nX, oY, -1, 0, grid))){\r\n                    return grid[nX][oY]\r\n                }\r\n                oY = oY + dY\r\n                if (blocked(nX, oY, 0, 0, grid)){\r\n                    return\r\n                }\r\n                if (grid[nX][oY] === finishNode){\r\n                    return finishNode\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n    return jump(nX, nY, dX, dY, grid, finishNode)\r\n}\r\nexport function orthJPS(grid,startNode,finishNode,h){\r\n    var openList = new Heap(function(nodeA, nodeB) {return nodeA.fscore - nodeB.fscore})\r\n    startNode.gscore = 0 ;\r\n    startNode.fscore = 0 ; \r\n    openList.push(startNode);\r\n    startNode.inopen = true;\r\n    const visitedNodesInOrder = [];\r\n    while (!openList.empty()){\r\n        var node = openList.pop();\r\n        node.inclosed = true;\r\n        visitedNodesInOrder.push(node)\r\n        if (node === finishNode){\r\n            console.log(\"We have successfully found a path\")\r\n            return visitedNodesInOrder;\r\n        }\r\n        var successors = identifySuccessors(node,grid,finishNode);\r\n        for (var i = 0 ;i < successors.length;i++){\r\n            var successor = successors[i];\r\n            if (!successor.inclosed){\r\n                var val = node.gscore + length(node,successor,h)\r\n                if (!successor.inopen || val < successor.gscore){\r\n                    successor.gscore = val;\r\n                    successor.hscore = heurestics(successor,finishNode,h)\r\n                    successor.fscore = successor.gscore + successor.hscore*successor.wallweight\r\n                    successor.previousNode = node\r\n                    if (!successor.inopen){\r\n                        openList.push(successor)\r\n                        successor.inopen = true\r\n                    }\r\n                    else{\r\n                        openList.updateItem(successor)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return visitedNodesInOrder\r\n}\r\nexport function orthogonalans(finishNode,grid){\r\n    var curr = finishNode\r\n    const nodesInShortestPathOrder = [];\r\n    while (curr !== null){\r\n        if (curr.previousNode){\r\n            var parent = curr.previousNode\r\n            var direc = direction(curr,parent)\r\n            var dX = direc[0] ; var dY = direc[1]\r\n            if ((dX === 0 && dY !== 0)|| (dY === 0 && dX !== 0)){\r\n                if (dY === 1){\r\n                    if (parent.col < curr.col){\r\n                        for (var a = parent.col + 1 ; a<curr.col ; a++){\r\n                            nodesInShortestPathOrder.push(grid[curr.row][a])\r\n                        }\r\n                    }\r\n                    else if (parent.col > curr.col){\r\n                        for (var b = parent.col ; b > curr.col ; b--){\r\n                            nodesInShortestPathOrder.push(grid[curr.row][b])\r\n                        }\r\n                    }\r\n                }\r\n                else{\r\n                    if (parent.row < curr.row){\r\n                        for (var c = parent.row + 1 ; c<curr.row ; c++){\r\n                            nodesInShortestPathOrder.push(grid[c][curr.col])\r\n                        }\r\n                    }\r\n                    else if (parent.row > curr.row){\r\n                        for (var d = parent.row  ; d > curr.row ; d--){\r\n                            nodesInShortestPathOrder.push(grid[d][curr.col])\r\n                        }\r\n                    }\r\n                }\r\n                nodesInShortestPathOrder.push(curr);\r\n                curr = curr.previousNode;\r\n            }\r\n            else{\r\n                var xcord = curr.row ; var ycord = parent.col;\r\n                if (parent.row < curr.row){\r\n                    for (var j = parent.row+1 ; j < xcord+1;j++){\r\n                        nodesInShortestPathOrder.push(grid[j][ycord]);\r\n                    }\r\n                }\r\n                else if (parent.row > curr.row){\r\n                    for (var k = parent.row-1 ; k>xcord +1;k--){\r\n                        nodesInShortestPathOrder.push(grid[k][ycord])\r\n                    }\r\n                }\r\n                if (parent.col < curr.col){\r\n                    for (var l = parent.col+1;l < curr.col ; l++){\r\n                        nodesInShortestPathOrder.push(grid[xcord][l])\r\n                    }\r\n                }\r\n                else if (parent.col > curr.col){\r\n                    for (var m = parent.col-1; m> curr.col ;m--){\r\n                        nodesInShortestPathOrder.push(grid[xcord][m])\r\n                    }\r\n                }\r\n                nodesInShortestPathOrder.push(curr);\r\n                curr = curr.previousNode;\r\n            }\r\n        }\r\n        else{\r\n            nodesInShortestPathOrder.push(curr)\r\n            curr = curr.previousNode\r\n        }\r\n    }\r\n    return nodesInShortestPathOrder\r\n\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      isWallweight,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isWallweight\r\n      ? \"node-wallweight\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport { Astar } from \"../algorithms/astar\";\r\nimport { Bestfs } from \"../algorithms/Bestfs\";\r\nimport { bfs } from \"../algorithms/bfs\";\r\nimport { bidfsans, bidijkstra } from \"../algorithms/bi-dijkstra\";\r\nimport { BiAstar } from \"../algorithms/biastar\";\r\nimport { BiBestfs } from \"../algorithms/BiBestfs\";\r\nimport { bbfs, bibfsans } from \"../algorithms/bibfs\";\r\nimport { BiIastar } from \"../algorithms/BiIastar\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../algorithms/dijkstra\";\r\nimport { Iastar } from \"../algorithms/Iastar\";\r\nimport { IBestfs } from \"../algorithms/IBestfs\";\r\nimport { IDAstar } from \"../algorithms/IDAstar_new\";\r\nimport { jps, jpsans } from \"../algorithms/jps\";\r\nimport { orthJPS, orthogonalans } from \"../algorithms/orthJPS\";\r\nimport img1 from \"../images/marsmap1k.jpg\";\r\nimport Node from \"./Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\n\r\nconst START_NODE_ROW = 0;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 40;\r\nconst t_rows = 20;\r\nconst t_cols = 50;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      wallweight: 99999999,\r\n      mouseIsPressed: false,\r\n      fin: false,\r\n      inf: false,\r\n      pause: false,\r\n    };\r\n    this.handleOptionChangefinite = this.handleOptionChangefinite.bind(this);\r\n    this.handleOptionChangeinfinite = this.handleOptionChangeinfinite.bind(\r\n      this\r\n    );\r\n    // this.handleCheckfinite = this.handleCheckfinite.bind(this);\r\n    this.handleChange2 = this.handleChange2.bind(this);\r\n    this.handleSubmit = this.handleSubmit.bind(this);\r\n  }\r\n  handleOptionChangefinite(event) {\r\n    if (!this.state.fin) {\r\n      this.state.fin = true;\r\n      this.state.wallweight = parseInt(\r\n        prompt(\"Please enter the value of wall weight\")\r\n      );\r\n      if (!this.state.wallweight) {\r\n        this.state.wallweight = 99999999;\r\n      }\r\n    }\r\n\r\n    console.log(this.state.wallweight);\r\n  }\r\n  handleOptionChangeinfinite(event) {\r\n    if (this.state.fin) {\r\n      this.state.fin = false;\r\n      this.state.wallweight = 99999999;\r\n    }\r\n    console.log(this.state.wallweight);\r\n  }\r\n  handleChange2(event) {\r\n    console.log(\"getting weighted wall\");\r\n    this.setState({ wallweight: event.target.value });\r\n  }\r\n  handleSubmit(event) {\r\n    alert(\"A name was submitted: \" + this.state.wallweight);\r\n    event.preventDefault();\r\n  }\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n    document.body.style.backgroundImage = `url(${img1})`;\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(\r\n      this.state.grid,\r\n      row,\r\n      col,\r\n      this.state.wallweight,\r\n      this.state.fin\r\n    );\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(\r\n      this.state.grid,\r\n      row,\r\n      col,\r\n      this.state.wallweight,\r\n      this.state.fin\r\n    );\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 1; i <= visitedNodesInOrder.length; i++) {\r\n      console.log(this.state.pause);\r\n\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n\r\n      if (\r\n        visitedNodesInOrder[i].isWall == false &&\r\n        visitedNodesInOrder[i].isWallweight == false\r\n      ) {\r\n        setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n          if (!node.isStart && !node.isFinish) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visited\";\r\n          }\r\n        }, 10 * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 1; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if (!node.isStart && !node.isFinish) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }\r\n      }, 50 * i);\r\n    }\r\n  }\r\n  visualizeOrthAstar() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = Astar(grid, startNode, finishNode, 4, false);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeAstar() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = Astar(grid, startNode, finishNode, 4, true);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBiAstarWithDiagonals() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = BiAstar(grid, startNode, finishNode, 1, true);\r\n    const n = visitedNodesInOrder.shift();\r\n    console.log(n[0].nex);\r\n    console.log(n[0].previousNode);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBiAstarNodiagoanls() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = BiAstar(grid, startNode, finishNode, 1, false);\r\n    const n = visitedNodesInOrder.shift();\r\n    console.log(n[0].nex);\r\n    console.log(n[0].previousNode);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeJPS() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = jps(grid, startNode, finishNode, 4);\r\n    const nodesInShortestPathOrder = jpsans(finishNode, grid);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBFS() {\r\n    console.log(this.state.wallweight);\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode, false);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBBFS() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bbfs(grid, startNode, finishNode, false);\r\n    const n = visitedNodesInOrder.shift();\r\n    //const nodesInShortestPathOrder = getNodesInShortestPathOrder(n[0]);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBDBFS() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bbfs(grid, startNode, finishNode, true);\r\n    const n = visitedNodesInOrder.shift();\r\n    //const nodesInShortestPathOrder = getNodesInShortestPathOrder(n[0]);\r\n    const nodesInShortestPathOrder = bibfsans(n[0]);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeBFSwithdiagonals() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = bfs(grid, startNode, finishNode, true);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n  visualizeOrthJPS() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = orthJPS(grid, startNode, finishNode, 4);\r\n    const nodesInShortestPathOrder = orthogonalans(finishNode, grid);\r\n    this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  //shreeya\r\n  visualizeDijkstra() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = dijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIntelligentAstar() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Manhattan\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = Iastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiIntelligentAstar() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Manhattan\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = BiIastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      console.log(ans);\r\n      console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBestfs() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = Bestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIBestfs() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = IBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiDijkstra() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = bidijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      console.log(ans);\r\n      console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n\r\n  visualizeBiBestfs() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Octile\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = BiBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      console.log(ans);\r\n      console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIDAstar() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Octile\";\r\n    var diagonalallowed = false;\r\n    const visitedNodesInOrder = IDAstar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeDijkstraDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = dijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIntelligentAstarDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Manhattan\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = Iastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiIntelligentAstarDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Manhattan\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = BiIastar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      console.log(ans);\r\n      console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBestfsDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = Bestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIBestfsDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Diagonal\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = IBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeBiDijkstraDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = bidijkstra(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      console.log(ans);\r\n      console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n\r\n  visualizeBiBestfsDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Octile\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = BiBestfs(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      console.log(visitedNodesInOrder);\r\n      const ans = visitedNodesInOrder.shift();\r\n      console.log(ans);\r\n      console.log(ans[0]);\r\n      const tempo = grid[ans[0].row][ans[0].col];\r\n      const nodesInShortestPathOrder = bidfsans(tempo);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  visualizeIDAstarDiag() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    var heuristic = \"Octile\";\r\n    var diagonalallowed = true;\r\n    const visitedNodesInOrder = IDAstar(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      heuristic,\r\n      diagonalallowed\r\n    );\r\n    if (visitedNodesInOrder) {\r\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n      console.log(visitedNodesInOrder);\r\n      console.log(nodesInShortestPathOrder);\r\n      this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    } else {\r\n      console.log(\"Path Blocked\");\r\n    }\r\n  }\r\n  clearwall() {\r\n    const grid1 = this.state.grid;\r\n    for (let row = 0; row < t_rows; row++) {\r\n      for (let col = 0; col < t_cols; col++) {\r\n        const node = grid1[row][col];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node\";\r\n      }\r\n    }\r\n\r\n    const node = grid1[START_NODE_ROW][START_NODE_COL];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node-start\";\r\n    const node1 = grid1[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    document.getElementById(`node-${node1.row}-${node1.col}`).className =\r\n      \"node node-finish\";\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  pauseSearch() {\r\n    let bool1 = this.state.pause;\r\n    bool1 = true;\r\n    this.setState({ pause: bool1 });\r\n  }\r\n\r\n  clearPath() {\r\n    console.log(\"calling clear path\");\r\n    const grid1 = this.state.grid;\r\n\r\n    for (let row = 0; row < t_rows; row++) {\r\n      for (let col = 0; col < t_cols; col++) {\r\n        let node = grid1[row][col];\r\n\r\n        if (!node.isWall && !node.isWallweight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node\";\r\n        } else if (node.isWallweight) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-wallweight\";\r\n        }\r\n        node.distance = Infinity;\r\n        node.previousNode = null;\r\n        node.next = null;\r\n        node.nex = null;\r\n        node.gscore = Infinity;\r\n        node.hscore = Infinity;\r\n        node.fscore = Infinity;\r\n        node.inclosed = false;\r\n        node.inopen = false;\r\n        node.startvisited = false;\r\n        node.endvisited = false;\r\n        node.isVisited = false;\r\n      }\r\n    }\r\n    const node = grid1[START_NODE_ROW][START_NODE_COL];\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n      \"node node-start\";\r\n    const node1 = grid1[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    document.getElementById(`node-${node1.row}-${node1.col}`).className =\r\n      \"node node-finish\";\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed, fin } = this.state;\r\n\r\n    return (\r\n      <>\r\n        <div className=\"button-wrapper2\">\r\n          <div className=\"button2\">SELECT ALGORITHM</div>\r\n          {/* <div class=\"testf\"> */}\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>Dijkstra Algorithm</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeDijkstra()}>Dijkstra</li>\r\n                <li onClick={() => this.visualizeBiDijkstra()}>\r\n                  Bi-directional\r\n                </li>\r\n                <li onClick={() => this.visualizeDijkstraDiag()}>Digonal</li>\r\n                <li onClick={() => this.visualizeBiDijkstraDiag()}>\r\n                  BiDir+diagonal\r\n                </li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>BFS Algorithm</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeBFS()}>BFS</li>\r\n                <li onClick={() => this.visualizeBBFS()}>Bi-directional</li>\r\n                <li onClick={() => this.visualizeBFSwithdiagonals()}>\r\n                  Diagonal\r\n                </li>\r\n                <li onClick={() => this.visualizeBDBFS()}>BiDir+diagonal</li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>Intelligent A-Star Algorithm</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeIntelligentAstar()}>A-Star</li>\r\n                <li onClick={() => this.visualizeBiIntelligentAstar()}>\r\n                  Bi-Directional\r\n                </li>\r\n                <li onClick={() => this.visualizeIntelligentAstarDiag()}>\r\n                  Diagonal\r\n                </li>\r\n                <li onClick={() => this.visualizeBiIntelligentAstarDiag()}>\r\n                  BiDir+diagonal\r\n                </li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>A-Star Algorithm</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeAstar()}>A-Star</li>\r\n                <li onClick={() => this.visualizeBiAstarNodiagoanls()}>\r\n                  Bi-directional\r\n                </li>\r\n                <li onClick={() => this.visualizeOrthAstar()}>Orthogal</li>\r\n                <li onClick={() => this.visualizeBiAstarWithDiagonals()}>\r\n                  Bidir+Diagonal\r\n                </li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>Best first Search</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeBestfs()}>Bestfs</li>\r\n                <li onClick={() => this.visualizeBiBestfs()}>Bi-directional</li>\r\n                <li onClick={() => this.visualizeBestfsDiag()}>Diagonal</li>\r\n                <li onClick={() => this.visualizeBiBestfsDiag()}>\r\n                  BiDir+diagonal\r\n                </li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>Intelligent Best first Search</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeIBestfs()}>option1</li>\r\n                <li onClick={() => this.visualizeBiBestfs()}>option2</li>\r\n                <li onClick={() => this.visualizeIBestfsDiag()}>option3</li>\r\n                <li onClick={() => this.visualizeBiBestfsDiag()}>option4</li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>IDA Star</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeIDAstar()}>IDA-Star</li>\r\n                <li onClick={() => this.visualizeIDAstarDiag()}>Diagonal</li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div class=\"buttf2\" tabindex=\"1\">\r\n            <div class=\"buttf\">\r\n              <div class=\"buttonfi\">\r\n                <a>Jump Point</a>\r\n              </div>\r\n              <div class=\"optf\">\r\n                <li onClick={() => this.visualizeJPS()}>Jump Point</li>\r\n                <li onClick={() => this.visualizeOrthJPS()}>Orthogonal</li>\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <div className=\"walls\">\r\n            WALLS\r\n            <div className=\"wallweight\">\r\n              <input\r\n                type=\"radio\"\r\n                id=\"infiwall\"\r\n                name=\"radiowall\"\r\n                value=\"finite\"\r\n                checked={!this.state.fin}\r\n                onChange={this.handleOptionChangeinfinite}\r\n              />\r\n              <label for=\"infiwall\">Infinite Wall</label>\r\n\r\n              <input\r\n                type=\"radio\"\r\n                id=\"fiwall\"\r\n                name=\"radiowall\"\r\n                value=\"infinite\"\r\n                checked={this.state.fin}\r\n                onChange={this.handleOptionChangefinite}\r\n              />\r\n              <label for=\"fiwall\">Finite Walls</label>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"inibutt\">\r\n          <div className=\"startendwrap\">\r\n            <div\r\n              className=\"pauseresume\"\r\n              tabIndex=\"2\"\r\n              onClick={() =>\r\n                alert(`            Visualization is paused.\r\n          Click on Resume to continue.\r\n              `)\r\n              }\r\n            ></div>\r\n          </div>\r\n\r\n          <div className=\"iniwrap\">\r\n            <div className=\"pathwall\" onClick={(grid) => this.clearPath(grid)}>\r\n              Clear Path\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"startendwrap\">\r\n            <div\r\n              onClick={async () => {\r\n                window.location =\r\n                  \"https://hackgod2000.github.io/TouchDown.js/#/end\";\r\n              }}\r\n              className=\"startend2\"\r\n            >\r\n              END\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"iniwrap\">\r\n            <div className=\"pathwall\" onClick={(grid) => this.clearwall(grid)}>\r\n              Clear Wall\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isFinish,\r\n                    isStart,\r\n                    isWall,\r\n                    isWallweight,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      isWallweight={isWallweight}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < t_rows; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < t_cols; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    isWallweight: false,\r\n    wallweight: 1,\r\n    previousNode: null,\r\n    gscore: Infinity,\r\n    fscore: Infinity,\r\n    hscore: Infinity,\r\n    inclosed: false,\r\n    inopen: false,\r\n    startvisited: false,\r\n    endvisited: false,\r\n    nex: null,\r\n    next: null,\r\n  };\r\n};\r\nconst getNewGridWithWallToggled = (grid, row, col, weight, fin) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall && !fin,\r\n    isWallweight: !node.isWallweight && fin,\r\n  };\r\n  if (newNode.isWall || newNode.isWallweight) {\r\n    newNode.wallweight = weight;\r\n  }\r\n  newGrid[row][col] = newNode;\r\n  console.log(newGrid[row][col]);\r\n  return newGrid;\r\n};\r\n","import React from \"react\";\r\nimport { HashRouter as Router, Route, Switch } from \"react-router-dom\";\r\nimport Endpage from \"./Components/endpage\";\r\nimport Model from \"./Components/Model\";\r\nimport PathfindingVisualizer from \"./Components/PathfindingVisualizer/PathfindingVisualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <Router>\r\n      <Switch>\r\n        <div className=\"App\">\r\n          <Route exact path=\"/\">\r\n            <Model />\r\n          </Route>\r\n          <Route path=\"/algo\">\r\n            <PathfindingVisualizer />\r\n          </Route>\r\n          <Route path=\"/end\">\r\n            <Endpage />\r\n          </Route>\r\n        </div>\r\n      </Switch>\r\n    </Router>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}